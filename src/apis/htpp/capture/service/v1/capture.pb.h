// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apis/htpp/capture/service/v1/capture.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
namespace htpp {
namespace capture {
namespace service {
namespace v1 {
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageReply;
struct ImageReplyDefaultTypeInternal;
extern ImageReplyDefaultTypeInternal _ImageReply_default_instance_;
class ImageSrc;
struct ImageSrcDefaultTypeInternal;
extern ImageSrcDefaultTypeInternal _ImageSrc_default_instance_;
class ImageWithAreaAndSrcReply;
struct ImageWithAreaAndSrcReplyDefaultTypeInternal;
extern ImageWithAreaAndSrcReplyDefaultTypeInternal _ImageWithAreaAndSrcReply_default_instance_;
class ImageWithAreaReply;
struct ImageWithAreaReplyDefaultTypeInternal;
extern ImageWithAreaReplyDefaultTypeInternal _ImageWithAreaReply_default_instance_;
class ImageWithSrcReply;
struct ImageWithSrcReplyDefaultTypeInternal;
extern ImageWithSrcReplyDefaultTypeInternal _ImageWithSrcReply_default_instance_;
class ImagesReply;
struct ImagesReplyDefaultTypeInternal;
extern ImagesReplyDefaultTypeInternal _ImagesReply_default_instance_;
class ImagesWithAreaAndSrcReply;
struct ImagesWithAreaAndSrcReplyDefaultTypeInternal;
extern ImagesWithAreaAndSrcReplyDefaultTypeInternal _ImagesWithAreaAndSrcReply_default_instance_;
class ImagesWithAreaAndSrcReply_Data;
struct ImagesWithAreaAndSrcReply_DataDefaultTypeInternal;
extern ImagesWithAreaAndSrcReply_DataDefaultTypeInternal _ImagesWithAreaAndSrcReply_Data_default_instance_;
class ImagesWithAreaReply;
struct ImagesWithAreaReplyDefaultTypeInternal;
extern ImagesWithAreaReplyDefaultTypeInternal _ImagesWithAreaReply_default_instance_;
class ImagesWithAreaReply_Data;
struct ImagesWithAreaReply_DataDefaultTypeInternal;
extern ImagesWithAreaReply_DataDefaultTypeInternal _ImagesWithAreaReply_Data_default_instance_;
class ImagesWithSrcReply;
struct ImagesWithSrcReplyDefaultTypeInternal;
extern ImagesWithSrcReplyDefaultTypeInternal _ImagesWithSrcReply_default_instance_;
class ReadAllRequest;
struct ReadAllRequestDefaultTypeInternal;
extern ReadAllRequestDefaultTypeInternal _ReadAllRequest_default_instance_;
class ReadAllWithBinaryAndCalAreaAndSrcRequest;
struct ReadAllWithBinaryAndCalAreaAndSrcRequestDefaultTypeInternal;
extern ReadAllWithBinaryAndCalAreaAndSrcRequestDefaultTypeInternal _ReadAllWithBinaryAndCalAreaAndSrcRequest_default_instance_;
class ReadAllWithBinaryAndCalAreaRequest;
struct ReadAllWithBinaryAndCalAreaRequestDefaultTypeInternal;
extern ReadAllWithBinaryAndCalAreaRequestDefaultTypeInternal _ReadAllWithBinaryAndCalAreaRequest_default_instance_;
class ReadAllWithBinaryAndSrcRequest;
struct ReadAllWithBinaryAndSrcRequestDefaultTypeInternal;
extern ReadAllWithBinaryAndSrcRequestDefaultTypeInternal _ReadAllWithBinaryAndSrcRequest_default_instance_;
class ReadAllWithBinaryRequest;
struct ReadAllWithBinaryRequestDefaultTypeInternal;
extern ReadAllWithBinaryRequestDefaultTypeInternal _ReadAllWithBinaryRequest_default_instance_;
class ReadOneRequest;
struct ReadOneRequestDefaultTypeInternal;
extern ReadOneRequestDefaultTypeInternal _ReadOneRequest_default_instance_;
class ReadOneWithBinaryAndCalAreaAndSrcRequest;
struct ReadOneWithBinaryAndCalAreaAndSrcRequestDefaultTypeInternal;
extern ReadOneWithBinaryAndCalAreaAndSrcRequestDefaultTypeInternal _ReadOneWithBinaryAndCalAreaAndSrcRequest_default_instance_;
class ReadOneWithBinaryAndCalAreaRequest;
struct ReadOneWithBinaryAndCalAreaRequestDefaultTypeInternal;
extern ReadOneWithBinaryAndCalAreaRequestDefaultTypeInternal _ReadOneWithBinaryAndCalAreaRequest_default_instance_;
class ReadOneWithBinaryAndSrcRequest;
struct ReadOneWithBinaryAndSrcRequestDefaultTypeInternal;
extern ReadOneWithBinaryAndSrcRequestDefaultTypeInternal _ReadOneWithBinaryAndSrcRequest_default_instance_;
class ReadOneWithBinaryRequest;
struct ReadOneWithBinaryRequestDefaultTypeInternal;
extern ReadOneWithBinaryRequestDefaultTypeInternal _ReadOneWithBinaryRequest_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace capture
}  // namespace htpp
PROTOBUF_NAMESPACE_OPEN
template<> ::htpp::capture::service::v1::Image* Arena::CreateMaybeMessage<::htpp::capture::service::v1::Image>(Arena*);
template<> ::htpp::capture::service::v1::ImageReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImageReply>(Arena*);
template<> ::htpp::capture::service::v1::ImageSrc* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImageSrc>(Arena*);
template<> ::htpp::capture::service::v1::ImageWithAreaAndSrcReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImageWithAreaAndSrcReply>(Arena*);
template<> ::htpp::capture::service::v1::ImageWithAreaReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImageWithAreaReply>(Arena*);
template<> ::htpp::capture::service::v1::ImageWithSrcReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImageWithSrcReply>(Arena*);
template<> ::htpp::capture::service::v1::ImagesReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesReply>(Arena*);
template<> ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesWithAreaAndSrcReply>(Arena*);
template<> ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data>(Arena*);
template<> ::htpp::capture::service::v1::ImagesWithAreaReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesWithAreaReply>(Arena*);
template<> ::htpp::capture::service::v1::ImagesWithAreaReply_Data* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesWithAreaReply_Data>(Arena*);
template<> ::htpp::capture::service::v1::ImagesWithSrcReply* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ImagesWithSrcReply>(Arena*);
template<> ::htpp::capture::service::v1::ReadAllRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadAllRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadAllWithBinaryAndCalAreaAndSrcRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadAllWithBinaryAndCalAreaAndSrcRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadAllWithBinaryAndCalAreaRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadAllWithBinaryAndCalAreaRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadAllWithBinaryAndSrcRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadAllWithBinaryAndSrcRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadAllWithBinaryRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadAllWithBinaryRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadOneRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadOneRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadOneWithBinaryAndCalAreaAndSrcRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadOneWithBinaryAndCalAreaAndSrcRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadOneWithBinaryAndCalAreaRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadOneWithBinaryAndCalAreaRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadOneWithBinaryAndSrcRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadOneWithBinaryAndSrcRequest>(Arena*);
template<> ::htpp::capture::service::v1::ReadOneWithBinaryRequest* Arena::CreateMaybeMessage<::htpp::capture::service::v1::ReadOneWithBinaryRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace htpp {
namespace capture {
namespace service {
namespace v1 {

// ===================================================================

class ReadOneRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadOneRequest) */ {
 public:
  inline ReadOneRequest() : ReadOneRequest(nullptr) {}
  ~ReadOneRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOneRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOneRequest(const ReadOneRequest& from);
  ReadOneRequest(ReadOneRequest&& from) noexcept
    : ReadOneRequest() {
    *this = ::std::move(from);
  }

  inline ReadOneRequest& operator=(const ReadOneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOneRequest& operator=(ReadOneRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOneRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOneRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOneRequest*>(
               &_ReadOneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReadOneRequest& a, ReadOneRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOneRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOneRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOneRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOneRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOneRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadOneRequest& from) {
    ReadOneRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOneRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadOneRequest";
  }
  protected:
  explicit ReadOneRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1 [json_name = "id"];
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadOneRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadAllRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadAllRequest) */ {
 public:
  inline ReadAllRequest() : ReadAllRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReadAllRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAllRequest(const ReadAllRequest& from);
  ReadAllRequest(ReadAllRequest&& from) noexcept
    : ReadAllRequest() {
    *this = ::std::move(from);
  }

  inline ReadAllRequest& operator=(const ReadAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAllRequest& operator=(ReadAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAllRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAllRequest*>(
               &_ReadAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReadAllRequest& a, ReadAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAllRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAllRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAllRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadAllRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadAllRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadAllRequest";
  }
  protected:
  explicit ReadAllRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadAllRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadOneWithBinaryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadOneWithBinaryRequest) */ {
 public:
  inline ReadOneWithBinaryRequest() : ReadOneWithBinaryRequest(nullptr) {}
  ~ReadOneWithBinaryRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOneWithBinaryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOneWithBinaryRequest(const ReadOneWithBinaryRequest& from);
  ReadOneWithBinaryRequest(ReadOneWithBinaryRequest&& from) noexcept
    : ReadOneWithBinaryRequest() {
    *this = ::std::move(from);
  }

  inline ReadOneWithBinaryRequest& operator=(const ReadOneWithBinaryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOneWithBinaryRequest& operator=(ReadOneWithBinaryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOneWithBinaryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOneWithBinaryRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOneWithBinaryRequest*>(
               &_ReadOneWithBinaryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReadOneWithBinaryRequest& a, ReadOneWithBinaryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOneWithBinaryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOneWithBinaryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOneWithBinaryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOneWithBinaryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOneWithBinaryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadOneWithBinaryRequest& from) {
    ReadOneWithBinaryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOneWithBinaryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadOneWithBinaryRequest";
  }
  protected:
  explicit ReadOneWithBinaryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1 [json_name = "id"];
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadOneWithBinaryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadOneWithBinaryAndSrcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadOneWithBinaryAndSrcRequest) */ {
 public:
  inline ReadOneWithBinaryAndSrcRequest() : ReadOneWithBinaryAndSrcRequest(nullptr) {}
  ~ReadOneWithBinaryAndSrcRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOneWithBinaryAndSrcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOneWithBinaryAndSrcRequest(const ReadOneWithBinaryAndSrcRequest& from);
  ReadOneWithBinaryAndSrcRequest(ReadOneWithBinaryAndSrcRequest&& from) noexcept
    : ReadOneWithBinaryAndSrcRequest() {
    *this = ::std::move(from);
  }

  inline ReadOneWithBinaryAndSrcRequest& operator=(const ReadOneWithBinaryAndSrcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOneWithBinaryAndSrcRequest& operator=(ReadOneWithBinaryAndSrcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOneWithBinaryAndSrcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOneWithBinaryAndSrcRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOneWithBinaryAndSrcRequest*>(
               &_ReadOneWithBinaryAndSrcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReadOneWithBinaryAndSrcRequest& a, ReadOneWithBinaryAndSrcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOneWithBinaryAndSrcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOneWithBinaryAndSrcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOneWithBinaryAndSrcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOneWithBinaryAndSrcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOneWithBinaryAndSrcRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadOneWithBinaryAndSrcRequest& from) {
    ReadOneWithBinaryAndSrcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOneWithBinaryAndSrcRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadOneWithBinaryAndSrcRequest";
  }
  protected:
  explicit ReadOneWithBinaryAndSrcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1 [json_name = "id"];
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadOneWithBinaryAndSrcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadAllWithBinaryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadAllWithBinaryRequest) */ {
 public:
  inline ReadAllWithBinaryRequest() : ReadAllWithBinaryRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReadAllWithBinaryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAllWithBinaryRequest(const ReadAllWithBinaryRequest& from);
  ReadAllWithBinaryRequest(ReadAllWithBinaryRequest&& from) noexcept
    : ReadAllWithBinaryRequest() {
    *this = ::std::move(from);
  }

  inline ReadAllWithBinaryRequest& operator=(const ReadAllWithBinaryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAllWithBinaryRequest& operator=(ReadAllWithBinaryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAllWithBinaryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAllWithBinaryRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAllWithBinaryRequest*>(
               &_ReadAllWithBinaryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReadAllWithBinaryRequest& a, ReadAllWithBinaryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAllWithBinaryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAllWithBinaryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAllWithBinaryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAllWithBinaryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadAllWithBinaryRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadAllWithBinaryRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadAllWithBinaryRequest";
  }
  protected:
  explicit ReadAllWithBinaryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadAllWithBinaryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadAllWithBinaryAndSrcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadAllWithBinaryAndSrcRequest) */ {
 public:
  inline ReadAllWithBinaryAndSrcRequest() : ReadAllWithBinaryAndSrcRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReadAllWithBinaryAndSrcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAllWithBinaryAndSrcRequest(const ReadAllWithBinaryAndSrcRequest& from);
  ReadAllWithBinaryAndSrcRequest(ReadAllWithBinaryAndSrcRequest&& from) noexcept
    : ReadAllWithBinaryAndSrcRequest() {
    *this = ::std::move(from);
  }

  inline ReadAllWithBinaryAndSrcRequest& operator=(const ReadAllWithBinaryAndSrcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAllWithBinaryAndSrcRequest& operator=(ReadAllWithBinaryAndSrcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAllWithBinaryAndSrcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAllWithBinaryAndSrcRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAllWithBinaryAndSrcRequest*>(
               &_ReadAllWithBinaryAndSrcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReadAllWithBinaryAndSrcRequest& a, ReadAllWithBinaryAndSrcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAllWithBinaryAndSrcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAllWithBinaryAndSrcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAllWithBinaryAndSrcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAllWithBinaryAndSrcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadAllWithBinaryAndSrcRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadAllWithBinaryAndSrcRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadAllWithBinaryAndSrcRequest";
  }
  protected:
  explicit ReadAllWithBinaryAndSrcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadAllWithBinaryAndSrcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadOneWithBinaryAndCalAreaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaRequest) */ {
 public:
  inline ReadOneWithBinaryAndCalAreaRequest() : ReadOneWithBinaryAndCalAreaRequest(nullptr) {}
  ~ReadOneWithBinaryAndCalAreaRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOneWithBinaryAndCalAreaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOneWithBinaryAndCalAreaRequest(const ReadOneWithBinaryAndCalAreaRequest& from);
  ReadOneWithBinaryAndCalAreaRequest(ReadOneWithBinaryAndCalAreaRequest&& from) noexcept
    : ReadOneWithBinaryAndCalAreaRequest() {
    *this = ::std::move(from);
  }

  inline ReadOneWithBinaryAndCalAreaRequest& operator=(const ReadOneWithBinaryAndCalAreaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOneWithBinaryAndCalAreaRequest& operator=(ReadOneWithBinaryAndCalAreaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOneWithBinaryAndCalAreaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOneWithBinaryAndCalAreaRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOneWithBinaryAndCalAreaRequest*>(
               &_ReadOneWithBinaryAndCalAreaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReadOneWithBinaryAndCalAreaRequest& a, ReadOneWithBinaryAndCalAreaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOneWithBinaryAndCalAreaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOneWithBinaryAndCalAreaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOneWithBinaryAndCalAreaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOneWithBinaryAndCalAreaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOneWithBinaryAndCalAreaRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadOneWithBinaryAndCalAreaRequest& from) {
    ReadOneWithBinaryAndCalAreaRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOneWithBinaryAndCalAreaRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaRequest";
  }
  protected:
  explicit ReadOneWithBinaryAndCalAreaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1 [json_name = "id"];
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadOneWithBinaryAndCalAreaAndSrcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaAndSrcRequest) */ {
 public:
  inline ReadOneWithBinaryAndCalAreaAndSrcRequest() : ReadOneWithBinaryAndCalAreaAndSrcRequest(nullptr) {}
  ~ReadOneWithBinaryAndCalAreaAndSrcRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadOneWithBinaryAndCalAreaAndSrcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadOneWithBinaryAndCalAreaAndSrcRequest(const ReadOneWithBinaryAndCalAreaAndSrcRequest& from);
  ReadOneWithBinaryAndCalAreaAndSrcRequest(ReadOneWithBinaryAndCalAreaAndSrcRequest&& from) noexcept
    : ReadOneWithBinaryAndCalAreaAndSrcRequest() {
    *this = ::std::move(from);
  }

  inline ReadOneWithBinaryAndCalAreaAndSrcRequest& operator=(const ReadOneWithBinaryAndCalAreaAndSrcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadOneWithBinaryAndCalAreaAndSrcRequest& operator=(ReadOneWithBinaryAndCalAreaAndSrcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadOneWithBinaryAndCalAreaAndSrcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadOneWithBinaryAndCalAreaAndSrcRequest* internal_default_instance() {
    return reinterpret_cast<const ReadOneWithBinaryAndCalAreaAndSrcRequest*>(
               &_ReadOneWithBinaryAndCalAreaAndSrcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadOneWithBinaryAndCalAreaAndSrcRequest& a, ReadOneWithBinaryAndCalAreaAndSrcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadOneWithBinaryAndCalAreaAndSrcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadOneWithBinaryAndCalAreaAndSrcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadOneWithBinaryAndCalAreaAndSrcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadOneWithBinaryAndCalAreaAndSrcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadOneWithBinaryAndCalAreaAndSrcRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadOneWithBinaryAndCalAreaAndSrcRequest& from) {
    ReadOneWithBinaryAndCalAreaAndSrcRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadOneWithBinaryAndCalAreaAndSrcRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaAndSrcRequest";
  }
  protected:
  explicit ReadOneWithBinaryAndCalAreaAndSrcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int64 id = 1 [json_name = "id"];
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaAndSrcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadAllWithBinaryAndCalAreaRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaRequest) */ {
 public:
  inline ReadAllWithBinaryAndCalAreaRequest() : ReadAllWithBinaryAndCalAreaRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReadAllWithBinaryAndCalAreaRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAllWithBinaryAndCalAreaRequest(const ReadAllWithBinaryAndCalAreaRequest& from);
  ReadAllWithBinaryAndCalAreaRequest(ReadAllWithBinaryAndCalAreaRequest&& from) noexcept
    : ReadAllWithBinaryAndCalAreaRequest() {
    *this = ::std::move(from);
  }

  inline ReadAllWithBinaryAndCalAreaRequest& operator=(const ReadAllWithBinaryAndCalAreaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAllWithBinaryAndCalAreaRequest& operator=(ReadAllWithBinaryAndCalAreaRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAllWithBinaryAndCalAreaRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAllWithBinaryAndCalAreaRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAllWithBinaryAndCalAreaRequest*>(
               &_ReadAllWithBinaryAndCalAreaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadAllWithBinaryAndCalAreaRequest& a, ReadAllWithBinaryAndCalAreaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAllWithBinaryAndCalAreaRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAllWithBinaryAndCalAreaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAllWithBinaryAndCalAreaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAllWithBinaryAndCalAreaRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadAllWithBinaryAndCalAreaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadAllWithBinaryAndCalAreaRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaRequest";
  }
  protected:
  explicit ReadAllWithBinaryAndCalAreaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ReadAllWithBinaryAndCalAreaAndSrcRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaAndSrcRequest) */ {
 public:
  inline ReadAllWithBinaryAndCalAreaAndSrcRequest() : ReadAllWithBinaryAndCalAreaAndSrcRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReadAllWithBinaryAndCalAreaAndSrcRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadAllWithBinaryAndCalAreaAndSrcRequest(const ReadAllWithBinaryAndCalAreaAndSrcRequest& from);
  ReadAllWithBinaryAndCalAreaAndSrcRequest(ReadAllWithBinaryAndCalAreaAndSrcRequest&& from) noexcept
    : ReadAllWithBinaryAndCalAreaAndSrcRequest() {
    *this = ::std::move(from);
  }

  inline ReadAllWithBinaryAndCalAreaAndSrcRequest& operator=(const ReadAllWithBinaryAndCalAreaAndSrcRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadAllWithBinaryAndCalAreaAndSrcRequest& operator=(ReadAllWithBinaryAndCalAreaAndSrcRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadAllWithBinaryAndCalAreaAndSrcRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadAllWithBinaryAndCalAreaAndSrcRequest* internal_default_instance() {
    return reinterpret_cast<const ReadAllWithBinaryAndCalAreaAndSrcRequest*>(
               &_ReadAllWithBinaryAndCalAreaAndSrcRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadAllWithBinaryAndCalAreaAndSrcRequest& a, ReadAllWithBinaryAndCalAreaAndSrcRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadAllWithBinaryAndCalAreaAndSrcRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadAllWithBinaryAndCalAreaAndSrcRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadAllWithBinaryAndCalAreaAndSrcRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadAllWithBinaryAndCalAreaAndSrcRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReadAllWithBinaryAndCalAreaAndSrcRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReadAllWithBinaryAndCalAreaAndSrcRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaAndSrcRequest";
  }
  protected:
  explicit ReadAllWithBinaryAndCalAreaAndSrcRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ReadAllWithBinaryAndCalAreaAndSrcRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImageReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImageReply) */ {
 public:
  inline ImageReply() : ImageReply(nullptr) {}
  ~ImageReply() override;
  explicit PROTOBUF_CONSTEXPR ImageReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageReply(const ImageReply& from);
  ImageReply(ImageReply&& from) noexcept
    : ImageReply() {
    *this = ::std::move(from);
  }

  inline ImageReply& operator=(const ImageReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageReply& operator=(ImageReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageReply* internal_default_instance() {
    return reinterpret_cast<const ImageReply*>(
               &_ImageReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ImageReply& a, ImageReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageReply& from) {
    ImageReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImageReply";
  }
  protected:
  explicit ImageReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
  };
  // .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::htpp::capture::service::v1::Image& image() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::Image* release_image();
  ::htpp::capture::service::v1::Image* mutable_image();
  void set_allocated_image(::htpp::capture::service::v1::Image* image);
  private:
  const ::htpp::capture::service::v1::Image& _internal_image() const;
  ::htpp::capture::service::v1::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::htpp::capture::service::v1::Image* image);
  ::htpp::capture::service::v1::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImageReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::Image* image_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImageWithSrcReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImageWithSrcReply) */ {
 public:
  inline ImageWithSrcReply() : ImageWithSrcReply(nullptr) {}
  ~ImageWithSrcReply() override;
  explicit PROTOBUF_CONSTEXPR ImageWithSrcReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageWithSrcReply(const ImageWithSrcReply& from);
  ImageWithSrcReply(ImageWithSrcReply&& from) noexcept
    : ImageWithSrcReply() {
    *this = ::std::move(from);
  }

  inline ImageWithSrcReply& operator=(const ImageWithSrcReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageWithSrcReply& operator=(ImageWithSrcReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageWithSrcReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageWithSrcReply* internal_default_instance() {
    return reinterpret_cast<const ImageWithSrcReply*>(
               &_ImageWithSrcReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ImageWithSrcReply& a, ImageWithSrcReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageWithSrcReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageWithSrcReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageWithSrcReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageWithSrcReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageWithSrcReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageWithSrcReply& from) {
    ImageWithSrcReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageWithSrcReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImageWithSrcReply";
  }
  protected:
  explicit ImageWithSrcReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSrcFieldNumber = 1,
  };
  // .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
  bool has_image_src() const;
  private:
  bool _internal_has_image_src() const;
  public:
  void clear_image_src();
  const ::htpp::capture::service::v1::ImageSrc& image_src() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::ImageSrc* release_image_src();
  ::htpp::capture::service::v1::ImageSrc* mutable_image_src();
  void set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src);
  private:
  const ::htpp::capture::service::v1::ImageSrc& _internal_image_src() const;
  ::htpp::capture::service::v1::ImageSrc* _internal_mutable_image_src();
  public:
  void unsafe_arena_set_allocated_image_src(
      ::htpp::capture::service::v1::ImageSrc* image_src);
  ::htpp::capture::service::v1::ImageSrc* unsafe_arena_release_image_src();

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImageWithSrcReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::ImageSrc* image_src_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesReply) */ {
 public:
  inline ImagesReply() : ImagesReply(nullptr) {}
  ~ImagesReply() override;
  explicit PROTOBUF_CONSTEXPR ImagesReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesReply(const ImagesReply& from);
  ImagesReply(ImagesReply&& from) noexcept
    : ImagesReply() {
    *this = ::std::move(from);
  }

  inline ImagesReply& operator=(const ImagesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesReply& operator=(ImagesReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesReply* internal_default_instance() {
    return reinterpret_cast<const ImagesReply*>(
               &_ImagesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ImagesReply& a, ImagesReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesReply& from) {
    ImagesReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesReply";
  }
  protected:
  explicit ImagesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 1,
  };
  // repeated .htpp.capture.service.v1.Image images = 1 [json_name = "images"];
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::htpp::capture::service::v1::Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::Image >*
      mutable_images();
  private:
  const ::htpp::capture::service::v1::Image& _internal_images(int index) const;
  ::htpp::capture::service::v1::Image* _internal_add_images();
  public:
  const ::htpp::capture::service::v1::Image& images(int index) const;
  ::htpp::capture::service::v1::Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::Image >&
      images() const;

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::Image > images_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesWithSrcReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesWithSrcReply) */ {
 public:
  inline ImagesWithSrcReply() : ImagesWithSrcReply(nullptr) {}
  ~ImagesWithSrcReply() override;
  explicit PROTOBUF_CONSTEXPR ImagesWithSrcReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesWithSrcReply(const ImagesWithSrcReply& from);
  ImagesWithSrcReply(ImagesWithSrcReply&& from) noexcept
    : ImagesWithSrcReply() {
    *this = ::std::move(from);
  }

  inline ImagesWithSrcReply& operator=(const ImagesWithSrcReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesWithSrcReply& operator=(ImagesWithSrcReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesWithSrcReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesWithSrcReply* internal_default_instance() {
    return reinterpret_cast<const ImagesWithSrcReply*>(
               &_ImagesWithSrcReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ImagesWithSrcReply& a, ImagesWithSrcReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesWithSrcReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesWithSrcReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesWithSrcReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesWithSrcReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesWithSrcReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesWithSrcReply& from) {
    ImagesWithSrcReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesWithSrcReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesWithSrcReply";
  }
  protected:
  explicit ImagesWithSrcReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSrcFieldNumber = 1,
  };
  // repeated .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
  int image_src_size() const;
  private:
  int _internal_image_src_size() const;
  public:
  void clear_image_src();
  ::htpp::capture::service::v1::ImageSrc* mutable_image_src(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImageSrc >*
      mutable_image_src();
  private:
  const ::htpp::capture::service::v1::ImageSrc& _internal_image_src(int index) const;
  ::htpp::capture::service::v1::ImageSrc* _internal_add_image_src();
  public:
  const ::htpp::capture::service::v1::ImageSrc& image_src(int index) const;
  ::htpp::capture::service::v1::ImageSrc* add_image_src();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImageSrc >&
      image_src() const;

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesWithSrcReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImageSrc > image_src_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImageWithAreaReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImageWithAreaReply) */ {
 public:
  inline ImageWithAreaReply() : ImageWithAreaReply(nullptr) {}
  ~ImageWithAreaReply() override;
  explicit PROTOBUF_CONSTEXPR ImageWithAreaReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageWithAreaReply(const ImageWithAreaReply& from);
  ImageWithAreaReply(ImageWithAreaReply&& from) noexcept
    : ImageWithAreaReply() {
    *this = ::std::move(from);
  }

  inline ImageWithAreaReply& operator=(const ImageWithAreaReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageWithAreaReply& operator=(ImageWithAreaReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageWithAreaReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageWithAreaReply* internal_default_instance() {
    return reinterpret_cast<const ImageWithAreaReply*>(
               &_ImageWithAreaReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ImageWithAreaReply& a, ImageWithAreaReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageWithAreaReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageWithAreaReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageWithAreaReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageWithAreaReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageWithAreaReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageWithAreaReply& from) {
    ImageWithAreaReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageWithAreaReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImageWithAreaReply";
  }
  protected:
  explicit ImageWithAreaReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kPixelsFieldNumber = 2,
    kAreaFieldNumber = 3,
  };
  // .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::htpp::capture::service::v1::Image& image() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::Image* release_image();
  ::htpp::capture::service::v1::Image* mutable_image();
  void set_allocated_image(::htpp::capture::service::v1::Image* image);
  private:
  const ::htpp::capture::service::v1::Image& _internal_image() const;
  ::htpp::capture::service::v1::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::htpp::capture::service::v1::Image* image);
  ::htpp::capture::service::v1::Image* unsafe_arena_release_image();

  // int64 pixels = 2 [json_name = "pixels"];
  void clear_pixels();
  int64_t pixels() const;
  void set_pixels(int64_t value);
  private:
  int64_t _internal_pixels() const;
  void _internal_set_pixels(int64_t value);
  public:

  // double area = 3 [json_name = "area"];
  void clear_area();
  double area() const;
  void set_area(double value);
  private:
  double _internal_area() const;
  void _internal_set_area(double value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImageWithAreaReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::Image* image_;
    int64_t pixels_;
    double area_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImageWithAreaAndSrcReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImageWithAreaAndSrcReply) */ {
 public:
  inline ImageWithAreaAndSrcReply() : ImageWithAreaAndSrcReply(nullptr) {}
  ~ImageWithAreaAndSrcReply() override;
  explicit PROTOBUF_CONSTEXPR ImageWithAreaAndSrcReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageWithAreaAndSrcReply(const ImageWithAreaAndSrcReply& from);
  ImageWithAreaAndSrcReply(ImageWithAreaAndSrcReply&& from) noexcept
    : ImageWithAreaAndSrcReply() {
    *this = ::std::move(from);
  }

  inline ImageWithAreaAndSrcReply& operator=(const ImageWithAreaAndSrcReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageWithAreaAndSrcReply& operator=(ImageWithAreaAndSrcReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageWithAreaAndSrcReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageWithAreaAndSrcReply* internal_default_instance() {
    return reinterpret_cast<const ImageWithAreaAndSrcReply*>(
               &_ImageWithAreaAndSrcReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ImageWithAreaAndSrcReply& a, ImageWithAreaAndSrcReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageWithAreaAndSrcReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageWithAreaAndSrcReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageWithAreaAndSrcReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageWithAreaAndSrcReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageWithAreaAndSrcReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageWithAreaAndSrcReply& from) {
    ImageWithAreaAndSrcReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageWithAreaAndSrcReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImageWithAreaAndSrcReply";
  }
  protected:
  explicit ImageWithAreaAndSrcReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSrcFieldNumber = 1,
    kPixelsFieldNumber = 2,
    kAreaFieldNumber = 3,
  };
  // .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
  bool has_image_src() const;
  private:
  bool _internal_has_image_src() const;
  public:
  void clear_image_src();
  const ::htpp::capture::service::v1::ImageSrc& image_src() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::ImageSrc* release_image_src();
  ::htpp::capture::service::v1::ImageSrc* mutable_image_src();
  void set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src);
  private:
  const ::htpp::capture::service::v1::ImageSrc& _internal_image_src() const;
  ::htpp::capture::service::v1::ImageSrc* _internal_mutable_image_src();
  public:
  void unsafe_arena_set_allocated_image_src(
      ::htpp::capture::service::v1::ImageSrc* image_src);
  ::htpp::capture::service::v1::ImageSrc* unsafe_arena_release_image_src();

  // int64 pixels = 2 [json_name = "pixels"];
  void clear_pixels();
  int64_t pixels() const;
  void set_pixels(int64_t value);
  private:
  int64_t _internal_pixels() const;
  void _internal_set_pixels(int64_t value);
  public:

  // double area = 3 [json_name = "area"];
  void clear_area();
  double area() const;
  void set_area(double value);
  private:
  double _internal_area() const;
  void _internal_set_area(double value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImageWithAreaAndSrcReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::ImageSrc* image_src_;
    int64_t pixels_;
    double area_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesWithAreaReply_Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesWithAreaReply.Data) */ {
 public:
  inline ImagesWithAreaReply_Data() : ImagesWithAreaReply_Data(nullptr) {}
  ~ImagesWithAreaReply_Data() override;
  explicit PROTOBUF_CONSTEXPR ImagesWithAreaReply_Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesWithAreaReply_Data(const ImagesWithAreaReply_Data& from);
  ImagesWithAreaReply_Data(ImagesWithAreaReply_Data&& from) noexcept
    : ImagesWithAreaReply_Data() {
    *this = ::std::move(from);
  }

  inline ImagesWithAreaReply_Data& operator=(const ImagesWithAreaReply_Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesWithAreaReply_Data& operator=(ImagesWithAreaReply_Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesWithAreaReply_Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesWithAreaReply_Data* internal_default_instance() {
    return reinterpret_cast<const ImagesWithAreaReply_Data*>(
               &_ImagesWithAreaReply_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ImagesWithAreaReply_Data& a, ImagesWithAreaReply_Data& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesWithAreaReply_Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesWithAreaReply_Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesWithAreaReply_Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesWithAreaReply_Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesWithAreaReply_Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesWithAreaReply_Data& from) {
    ImagesWithAreaReply_Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesWithAreaReply_Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesWithAreaReply.Data";
  }
  protected:
  explicit ImagesWithAreaReply_Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kPixelsFieldNumber = 2,
    kAreaFieldNumber = 3,
  };
  // .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::htpp::capture::service::v1::Image& image() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::Image* release_image();
  ::htpp::capture::service::v1::Image* mutable_image();
  void set_allocated_image(::htpp::capture::service::v1::Image* image);
  private:
  const ::htpp::capture::service::v1::Image& _internal_image() const;
  ::htpp::capture::service::v1::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::htpp::capture::service::v1::Image* image);
  ::htpp::capture::service::v1::Image* unsafe_arena_release_image();

  // int64 pixels = 2 [json_name = "pixels"];
  void clear_pixels();
  int64_t pixels() const;
  void set_pixels(int64_t value);
  private:
  int64_t _internal_pixels() const;
  void _internal_set_pixels(int64_t value);
  public:

  // double area = 3 [json_name = "area"];
  void clear_area();
  double area() const;
  void set_area(double value);
  private:
  double _internal_area() const;
  void _internal_set_area(double value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesWithAreaReply.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::Image* image_;
    int64_t pixels_;
    double area_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesWithAreaReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesWithAreaReply) */ {
 public:
  inline ImagesWithAreaReply() : ImagesWithAreaReply(nullptr) {}
  ~ImagesWithAreaReply() override;
  explicit PROTOBUF_CONSTEXPR ImagesWithAreaReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesWithAreaReply(const ImagesWithAreaReply& from);
  ImagesWithAreaReply(ImagesWithAreaReply&& from) noexcept
    : ImagesWithAreaReply() {
    *this = ::std::move(from);
  }

  inline ImagesWithAreaReply& operator=(const ImagesWithAreaReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesWithAreaReply& operator=(ImagesWithAreaReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesWithAreaReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesWithAreaReply* internal_default_instance() {
    return reinterpret_cast<const ImagesWithAreaReply*>(
               &_ImagesWithAreaReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ImagesWithAreaReply& a, ImagesWithAreaReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesWithAreaReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesWithAreaReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesWithAreaReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesWithAreaReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesWithAreaReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesWithAreaReply& from) {
    ImagesWithAreaReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesWithAreaReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesWithAreaReply";
  }
  protected:
  explicit ImagesWithAreaReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImagesWithAreaReply_Data Data;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .htpp.capture.service.v1.ImagesWithAreaReply.Data data = 1 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::htpp::capture::service::v1::ImagesWithAreaReply_Data* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaReply_Data >*
      mutable_data();
  private:
  const ::htpp::capture::service::v1::ImagesWithAreaReply_Data& _internal_data(int index) const;
  ::htpp::capture::service::v1::ImagesWithAreaReply_Data* _internal_add_data();
  public:
  const ::htpp::capture::service::v1::ImagesWithAreaReply_Data& data(int index) const;
  ::htpp::capture::service::v1::ImagesWithAreaReply_Data* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaReply_Data >&
      data() const;

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesWithAreaReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaReply_Data > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesWithAreaAndSrcReply_Data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data) */ {
 public:
  inline ImagesWithAreaAndSrcReply_Data() : ImagesWithAreaAndSrcReply_Data(nullptr) {}
  ~ImagesWithAreaAndSrcReply_Data() override;
  explicit PROTOBUF_CONSTEXPR ImagesWithAreaAndSrcReply_Data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesWithAreaAndSrcReply_Data(const ImagesWithAreaAndSrcReply_Data& from);
  ImagesWithAreaAndSrcReply_Data(ImagesWithAreaAndSrcReply_Data&& from) noexcept
    : ImagesWithAreaAndSrcReply_Data() {
    *this = ::std::move(from);
  }

  inline ImagesWithAreaAndSrcReply_Data& operator=(const ImagesWithAreaAndSrcReply_Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesWithAreaAndSrcReply_Data& operator=(ImagesWithAreaAndSrcReply_Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesWithAreaAndSrcReply_Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesWithAreaAndSrcReply_Data* internal_default_instance() {
    return reinterpret_cast<const ImagesWithAreaAndSrcReply_Data*>(
               &_ImagesWithAreaAndSrcReply_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ImagesWithAreaAndSrcReply_Data& a, ImagesWithAreaAndSrcReply_Data& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesWithAreaAndSrcReply_Data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesWithAreaAndSrcReply_Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesWithAreaAndSrcReply_Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesWithAreaAndSrcReply_Data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesWithAreaAndSrcReply_Data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesWithAreaAndSrcReply_Data& from) {
    ImagesWithAreaAndSrcReply_Data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesWithAreaAndSrcReply_Data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data";
  }
  protected:
  explicit ImagesWithAreaAndSrcReply_Data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageSrcFieldNumber = 1,
    kPixelsFieldNumber = 2,
    kAreaFieldNumber = 3,
  };
  // .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
  bool has_image_src() const;
  private:
  bool _internal_has_image_src() const;
  public:
  void clear_image_src();
  const ::htpp::capture::service::v1::ImageSrc& image_src() const;
  PROTOBUF_NODISCARD ::htpp::capture::service::v1::ImageSrc* release_image_src();
  ::htpp::capture::service::v1::ImageSrc* mutable_image_src();
  void set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src);
  private:
  const ::htpp::capture::service::v1::ImageSrc& _internal_image_src() const;
  ::htpp::capture::service::v1::ImageSrc* _internal_mutable_image_src();
  public:
  void unsafe_arena_set_allocated_image_src(
      ::htpp::capture::service::v1::ImageSrc* image_src);
  ::htpp::capture::service::v1::ImageSrc* unsafe_arena_release_image_src();

  // int64 pixels = 2 [json_name = "pixels"];
  void clear_pixels();
  int64_t pixels() const;
  void set_pixels(int64_t value);
  private:
  int64_t _internal_pixels() const;
  void _internal_set_pixels(int64_t value);
  public:

  // double area = 3 [json_name = "area"];
  void clear_area();
  double area() const;
  void set_area(double value);
  private:
  double _internal_area() const;
  void _internal_set_area(double value);
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::htpp::capture::service::v1::ImageSrc* image_src_;
    int64_t pixels_;
    double area_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImagesWithAreaAndSrcReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImagesWithAreaAndSrcReply) */ {
 public:
  inline ImagesWithAreaAndSrcReply() : ImagesWithAreaAndSrcReply(nullptr) {}
  ~ImagesWithAreaAndSrcReply() override;
  explicit PROTOBUF_CONSTEXPR ImagesWithAreaAndSrcReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImagesWithAreaAndSrcReply(const ImagesWithAreaAndSrcReply& from);
  ImagesWithAreaAndSrcReply(ImagesWithAreaAndSrcReply&& from) noexcept
    : ImagesWithAreaAndSrcReply() {
    *this = ::std::move(from);
  }

  inline ImagesWithAreaAndSrcReply& operator=(const ImagesWithAreaAndSrcReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImagesWithAreaAndSrcReply& operator=(ImagesWithAreaAndSrcReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImagesWithAreaAndSrcReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImagesWithAreaAndSrcReply* internal_default_instance() {
    return reinterpret_cast<const ImagesWithAreaAndSrcReply*>(
               &_ImagesWithAreaAndSrcReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ImagesWithAreaAndSrcReply& a, ImagesWithAreaAndSrcReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ImagesWithAreaAndSrcReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImagesWithAreaAndSrcReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImagesWithAreaAndSrcReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImagesWithAreaAndSrcReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImagesWithAreaAndSrcReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImagesWithAreaAndSrcReply& from) {
    ImagesWithAreaAndSrcReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImagesWithAreaAndSrcReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImagesWithAreaAndSrcReply";
  }
  protected:
  explicit ImagesWithAreaAndSrcReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImagesWithAreaAndSrcReply_Data Data;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data data = 1 [json_name = "data"];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data >*
      mutable_data();
  private:
  const ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data& _internal_data(int index) const;
  ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* _internal_add_data();
  public:
  const ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data& data(int index) const;
  ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data >&
      data() const;

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImagesWithAreaAndSrcReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Image& from) {
    Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1 [json_name = "data"];
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// -------------------------------------------------------------------

class ImageSrc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:htpp.capture.service.v1.ImageSrc) */ {
 public:
  inline ImageSrc() : ImageSrc(nullptr) {}
  ~ImageSrc() override;
  explicit PROTOBUF_CONSTEXPR ImageSrc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageSrc(const ImageSrc& from);
  ImageSrc(ImageSrc&& from) noexcept
    : ImageSrc() {
    *this = ::std::move(from);
  }

  inline ImageSrc& operator=(const ImageSrc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageSrc& operator=(ImageSrc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageSrc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageSrc* internal_default_instance() {
    return reinterpret_cast<const ImageSrc*>(
               &_ImageSrc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ImageSrc& a, ImageSrc& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageSrc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageSrc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageSrc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageSrc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageSrc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImageSrc& from) {
    ImageSrc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageSrc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "htpp.capture.service.v1.ImageSrc";
  }
  protected:
  explicit ImageSrc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcFieldNumber = 1,
    kSrcFieldNumber = 2,
  };
  // bytes proc = 1 [json_name = "proc"];
  void clear_proc();
  const std::string& proc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_proc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_proc();
  PROTOBUF_NODISCARD std::string* release_proc();
  void set_allocated_proc(std::string* proc);
  private:
  const std::string& _internal_proc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proc(const std::string& value);
  std::string* _internal_mutable_proc();
  public:

  // bytes src = 2 [json_name = "src"];
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // @@protoc_insertion_point(class_scope:htpp.capture.service.v1.ImageSrc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proc_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReadOneRequest

// int64 id = 1 [json_name = "id"];
inline void ReadOneRequest::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReadOneRequest::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReadOneRequest::id() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ReadOneRequest.id)
  return _internal_id();
}
inline void ReadOneRequest::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReadOneRequest::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ReadOneRequest.id)
}

// -------------------------------------------------------------------

// ReadAllRequest

// -------------------------------------------------------------------

// ReadOneWithBinaryRequest

// int64 id = 1 [json_name = "id"];
inline void ReadOneWithBinaryRequest::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReadOneWithBinaryRequest::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReadOneWithBinaryRequest::id() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ReadOneWithBinaryRequest.id)
  return _internal_id();
}
inline void ReadOneWithBinaryRequest::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReadOneWithBinaryRequest::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ReadOneWithBinaryRequest.id)
}

// -------------------------------------------------------------------

// ReadOneWithBinaryAndSrcRequest

// int64 id = 1 [json_name = "id"];
inline void ReadOneWithBinaryAndSrcRequest::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReadOneWithBinaryAndSrcRequest::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReadOneWithBinaryAndSrcRequest::id() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ReadOneWithBinaryAndSrcRequest.id)
  return _internal_id();
}
inline void ReadOneWithBinaryAndSrcRequest::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReadOneWithBinaryAndSrcRequest::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ReadOneWithBinaryAndSrcRequest.id)
}

// -------------------------------------------------------------------

// ReadAllWithBinaryRequest

// -------------------------------------------------------------------

// ReadAllWithBinaryAndSrcRequest

// -------------------------------------------------------------------

// ReadOneWithBinaryAndCalAreaRequest

// int64 id = 1 [json_name = "id"];
inline void ReadOneWithBinaryAndCalAreaRequest::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReadOneWithBinaryAndCalAreaRequest::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReadOneWithBinaryAndCalAreaRequest::id() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaRequest.id)
  return _internal_id();
}
inline void ReadOneWithBinaryAndCalAreaRequest::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReadOneWithBinaryAndCalAreaRequest::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaRequest.id)
}

// -------------------------------------------------------------------

// ReadOneWithBinaryAndCalAreaAndSrcRequest

// int64 id = 1 [json_name = "id"];
inline void ReadOneWithBinaryAndCalAreaAndSrcRequest::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t ReadOneWithBinaryAndCalAreaAndSrcRequest::_internal_id() const {
  return _impl_.id_;
}
inline int64_t ReadOneWithBinaryAndCalAreaAndSrcRequest::id() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaAndSrcRequest.id)
  return _internal_id();
}
inline void ReadOneWithBinaryAndCalAreaAndSrcRequest::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void ReadOneWithBinaryAndCalAreaAndSrcRequest::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ReadOneWithBinaryAndCalAreaAndSrcRequest.id)
}

// -------------------------------------------------------------------

// ReadAllWithBinaryAndCalAreaRequest

// -------------------------------------------------------------------

// ReadAllWithBinaryAndCalAreaAndSrcRequest

// -------------------------------------------------------------------

// ImageReply

// .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
inline bool ImageReply::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool ImageReply::has_image() const {
  return _internal_has_image();
}
inline void ImageReply::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::htpp::capture::service::v1::Image& ImageReply::_internal_image() const {
  const ::htpp::capture::service::v1::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::Image&>(
      ::htpp::capture::service::v1::_Image_default_instance_);
}
inline const ::htpp::capture::service::v1::Image& ImageReply::image() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageReply.image)
  return _internal_image();
}
inline void ImageReply::unsafe_arena_set_allocated_image(
    ::htpp::capture::service::v1::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImageReply.image)
}
inline ::htpp::capture::service::v1::Image* ImageReply::release_image() {
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImageReply::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageReply.image)
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImageReply::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::htpp::capture::service::v1::Image* ImageReply::mutable_image() {
  ::htpp::capture::service::v1::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageReply.image)
  return _msg;
}
inline void ImageReply::set_allocated_image(::htpp::capture::service::v1::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageReply.image)
}

// -------------------------------------------------------------------

// ImageWithSrcReply

// .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
inline bool ImageWithSrcReply::_internal_has_image_src() const {
  return this != internal_default_instance() && _impl_.image_src_ != nullptr;
}
inline bool ImageWithSrcReply::has_image_src() const {
  return _internal_has_image_src();
}
inline void ImageWithSrcReply::clear_image_src() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_src_ != nullptr) {
    delete _impl_.image_src_;
  }
  _impl_.image_src_ = nullptr;
}
inline const ::htpp::capture::service::v1::ImageSrc& ImageWithSrcReply::_internal_image_src() const {
  const ::htpp::capture::service::v1::ImageSrc* p = _impl_.image_src_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::ImageSrc&>(
      ::htpp::capture::service::v1::_ImageSrc_default_instance_);
}
inline const ::htpp::capture::service::v1::ImageSrc& ImageWithSrcReply::image_src() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithSrcReply.image_src)
  return _internal_image_src();
}
inline void ImageWithSrcReply::unsafe_arena_set_allocated_image_src(
    ::htpp::capture::service::v1::ImageSrc* image_src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_src_);
  }
  _impl_.image_src_ = image_src;
  if (image_src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImageWithSrcReply.image_src)
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithSrcReply::release_image_src() {
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithSrcReply::unsafe_arena_release_image_src() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageWithSrcReply.image_src)
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithSrcReply::_internal_mutable_image_src() {
  
  if (_impl_.image_src_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::ImageSrc>(GetArenaForAllocation());
    _impl_.image_src_ = p;
  }
  return _impl_.image_src_;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithSrcReply::mutable_image_src() {
  ::htpp::capture::service::v1::ImageSrc* _msg = _internal_mutable_image_src();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageWithSrcReply.image_src)
  return _msg;
}
inline void ImageWithSrcReply::set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_src_;
  }
  if (image_src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_src);
    if (message_arena != submessage_arena) {
      image_src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_src, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_src_ = image_src;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageWithSrcReply.image_src)
}

// -------------------------------------------------------------------

// ImagesReply

// repeated .htpp.capture.service.v1.Image images = 1 [json_name = "images"];
inline int ImagesReply::_internal_images_size() const {
  return _impl_.images_.size();
}
inline int ImagesReply::images_size() const {
  return _internal_images_size();
}
inline void ImagesReply::clear_images() {
  _impl_.images_.Clear();
}
inline ::htpp::capture::service::v1::Image* ImagesReply::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesReply.images)
  return _impl_.images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::Image >*
ImagesReply::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:htpp.capture.service.v1.ImagesReply.images)
  return &_impl_.images_;
}
inline const ::htpp::capture::service::v1::Image& ImagesReply::_internal_images(int index) const {
  return _impl_.images_.Get(index);
}
inline const ::htpp::capture::service::v1::Image& ImagesReply::images(int index) const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesReply.images)
  return _internal_images(index);
}
inline ::htpp::capture::service::v1::Image* ImagesReply::_internal_add_images() {
  return _impl_.images_.Add();
}
inline ::htpp::capture::service::v1::Image* ImagesReply::add_images() {
  ::htpp::capture::service::v1::Image* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:htpp.capture.service.v1.ImagesReply.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::Image >&
ImagesReply::images() const {
  // @@protoc_insertion_point(field_list:htpp.capture.service.v1.ImagesReply.images)
  return _impl_.images_;
}

// -------------------------------------------------------------------

// ImagesWithSrcReply

// repeated .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
inline int ImagesWithSrcReply::_internal_image_src_size() const {
  return _impl_.image_src_.size();
}
inline int ImagesWithSrcReply::image_src_size() const {
  return _internal_image_src_size();
}
inline void ImagesWithSrcReply::clear_image_src() {
  _impl_.image_src_.Clear();
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithSrcReply::mutable_image_src(int index) {
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesWithSrcReply.image_src)
  return _impl_.image_src_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImageSrc >*
ImagesWithSrcReply::mutable_image_src() {
  // @@protoc_insertion_point(field_mutable_list:htpp.capture.service.v1.ImagesWithSrcReply.image_src)
  return &_impl_.image_src_;
}
inline const ::htpp::capture::service::v1::ImageSrc& ImagesWithSrcReply::_internal_image_src(int index) const {
  return _impl_.image_src_.Get(index);
}
inline const ::htpp::capture::service::v1::ImageSrc& ImagesWithSrcReply::image_src(int index) const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithSrcReply.image_src)
  return _internal_image_src(index);
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithSrcReply::_internal_add_image_src() {
  return _impl_.image_src_.Add();
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithSrcReply::add_image_src() {
  ::htpp::capture::service::v1::ImageSrc* _add = _internal_add_image_src();
  // @@protoc_insertion_point(field_add:htpp.capture.service.v1.ImagesWithSrcReply.image_src)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImageSrc >&
ImagesWithSrcReply::image_src() const {
  // @@protoc_insertion_point(field_list:htpp.capture.service.v1.ImagesWithSrcReply.image_src)
  return _impl_.image_src_;
}

// -------------------------------------------------------------------

// ImageWithAreaReply

// .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
inline bool ImageWithAreaReply::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool ImageWithAreaReply::has_image() const {
  return _internal_has_image();
}
inline void ImageWithAreaReply::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::htpp::capture::service::v1::Image& ImageWithAreaReply::_internal_image() const {
  const ::htpp::capture::service::v1::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::Image&>(
      ::htpp::capture::service::v1::_Image_default_instance_);
}
inline const ::htpp::capture::service::v1::Image& ImageWithAreaReply::image() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaReply.image)
  return _internal_image();
}
inline void ImageWithAreaReply::unsafe_arena_set_allocated_image(
    ::htpp::capture::service::v1::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImageWithAreaReply.image)
}
inline ::htpp::capture::service::v1::Image* ImageWithAreaReply::release_image() {
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImageWithAreaReply::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageWithAreaReply.image)
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImageWithAreaReply::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::htpp::capture::service::v1::Image* ImageWithAreaReply::mutable_image() {
  ::htpp::capture::service::v1::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageWithAreaReply.image)
  return _msg;
}
inline void ImageWithAreaReply::set_allocated_image(::htpp::capture::service::v1::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageWithAreaReply.image)
}

// int64 pixels = 2 [json_name = "pixels"];
inline void ImageWithAreaReply::clear_pixels() {
  _impl_.pixels_ = int64_t{0};
}
inline int64_t ImageWithAreaReply::_internal_pixels() const {
  return _impl_.pixels_;
}
inline int64_t ImageWithAreaReply::pixels() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaReply.pixels)
  return _internal_pixels();
}
inline void ImageWithAreaReply::_internal_set_pixels(int64_t value) {
  
  _impl_.pixels_ = value;
}
inline void ImageWithAreaReply::set_pixels(int64_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageWithAreaReply.pixels)
}

// double area = 3 [json_name = "area"];
inline void ImageWithAreaReply::clear_area() {
  _impl_.area_ = 0;
}
inline double ImageWithAreaReply::_internal_area() const {
  return _impl_.area_;
}
inline double ImageWithAreaReply::area() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaReply.area)
  return _internal_area();
}
inline void ImageWithAreaReply::_internal_set_area(double value) {
  
  _impl_.area_ = value;
}
inline void ImageWithAreaReply::set_area(double value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageWithAreaReply.area)
}

// -------------------------------------------------------------------

// ImageWithAreaAndSrcReply

// .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
inline bool ImageWithAreaAndSrcReply::_internal_has_image_src() const {
  return this != internal_default_instance() && _impl_.image_src_ != nullptr;
}
inline bool ImageWithAreaAndSrcReply::has_image_src() const {
  return _internal_has_image_src();
}
inline void ImageWithAreaAndSrcReply::clear_image_src() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_src_ != nullptr) {
    delete _impl_.image_src_;
  }
  _impl_.image_src_ = nullptr;
}
inline const ::htpp::capture::service::v1::ImageSrc& ImageWithAreaAndSrcReply::_internal_image_src() const {
  const ::htpp::capture::service::v1::ImageSrc* p = _impl_.image_src_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::ImageSrc&>(
      ::htpp::capture::service::v1::_ImageSrc_default_instance_);
}
inline const ::htpp::capture::service::v1::ImageSrc& ImageWithAreaAndSrcReply::image_src() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaAndSrcReply.image_src)
  return _internal_image_src();
}
inline void ImageWithAreaAndSrcReply::unsafe_arena_set_allocated_image_src(
    ::htpp::capture::service::v1::ImageSrc* image_src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_src_);
  }
  _impl_.image_src_ = image_src;
  if (image_src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImageWithAreaAndSrcReply.image_src)
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithAreaAndSrcReply::release_image_src() {
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithAreaAndSrcReply::unsafe_arena_release_image_src() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageWithAreaAndSrcReply.image_src)
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithAreaAndSrcReply::_internal_mutable_image_src() {
  
  if (_impl_.image_src_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::ImageSrc>(GetArenaForAllocation());
    _impl_.image_src_ = p;
  }
  return _impl_.image_src_;
}
inline ::htpp::capture::service::v1::ImageSrc* ImageWithAreaAndSrcReply::mutable_image_src() {
  ::htpp::capture::service::v1::ImageSrc* _msg = _internal_mutable_image_src();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageWithAreaAndSrcReply.image_src)
  return _msg;
}
inline void ImageWithAreaAndSrcReply::set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_src_;
  }
  if (image_src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_src);
    if (message_arena != submessage_arena) {
      image_src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_src, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_src_ = image_src;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageWithAreaAndSrcReply.image_src)
}

// int64 pixels = 2 [json_name = "pixels"];
inline void ImageWithAreaAndSrcReply::clear_pixels() {
  _impl_.pixels_ = int64_t{0};
}
inline int64_t ImageWithAreaAndSrcReply::_internal_pixels() const {
  return _impl_.pixels_;
}
inline int64_t ImageWithAreaAndSrcReply::pixels() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaAndSrcReply.pixels)
  return _internal_pixels();
}
inline void ImageWithAreaAndSrcReply::_internal_set_pixels(int64_t value) {
  
  _impl_.pixels_ = value;
}
inline void ImageWithAreaAndSrcReply::set_pixels(int64_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageWithAreaAndSrcReply.pixels)
}

// double area = 3 [json_name = "area"];
inline void ImageWithAreaAndSrcReply::clear_area() {
  _impl_.area_ = 0;
}
inline double ImageWithAreaAndSrcReply::_internal_area() const {
  return _impl_.area_;
}
inline double ImageWithAreaAndSrcReply::area() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageWithAreaAndSrcReply.area)
  return _internal_area();
}
inline void ImageWithAreaAndSrcReply::_internal_set_area(double value) {
  
  _impl_.area_ = value;
}
inline void ImageWithAreaAndSrcReply::set_area(double value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageWithAreaAndSrcReply.area)
}

// -------------------------------------------------------------------

// ImagesWithAreaReply_Data

// .htpp.capture.service.v1.Image image = 1 [json_name = "image"];
inline bool ImagesWithAreaReply_Data::_internal_has_image() const {
  return this != internal_default_instance() && _impl_.image_ != nullptr;
}
inline bool ImagesWithAreaReply_Data::has_image() const {
  return _internal_has_image();
}
inline void ImagesWithAreaReply_Data::clear_image() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_ != nullptr) {
    delete _impl_.image_;
  }
  _impl_.image_ = nullptr;
}
inline const ::htpp::capture::service::v1::Image& ImagesWithAreaReply_Data::_internal_image() const {
  const ::htpp::capture::service::v1::Image* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::Image&>(
      ::htpp::capture::service::v1::_Image_default_instance_);
}
inline const ::htpp::capture::service::v1::Image& ImagesWithAreaReply_Data::image() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaReply.Data.image)
  return _internal_image();
}
inline void ImagesWithAreaReply_Data::unsafe_arena_set_allocated_image(
    ::htpp::capture::service::v1::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImagesWithAreaReply.Data.image)
}
inline ::htpp::capture::service::v1::Image* ImagesWithAreaReply_Data::release_image() {
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImagesWithAreaReply_Data::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImagesWithAreaReply.Data.image)
  
  ::htpp::capture::service::v1::Image* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::Image* ImagesWithAreaReply_Data::_internal_mutable_image() {
  
  if (_impl_.image_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::Image>(GetArenaForAllocation());
    _impl_.image_ = p;
  }
  return _impl_.image_;
}
inline ::htpp::capture::service::v1::Image* ImagesWithAreaReply_Data::mutable_image() {
  ::htpp::capture::service::v1::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesWithAreaReply.Data.image)
  return _msg;
}
inline void ImagesWithAreaReply_Data::set_allocated_image(::htpp::capture::service::v1::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_ = image;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImagesWithAreaReply.Data.image)
}

// int64 pixels = 2 [json_name = "pixels"];
inline void ImagesWithAreaReply_Data::clear_pixels() {
  _impl_.pixels_ = int64_t{0};
}
inline int64_t ImagesWithAreaReply_Data::_internal_pixels() const {
  return _impl_.pixels_;
}
inline int64_t ImagesWithAreaReply_Data::pixels() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaReply.Data.pixels)
  return _internal_pixels();
}
inline void ImagesWithAreaReply_Data::_internal_set_pixels(int64_t value) {
  
  _impl_.pixels_ = value;
}
inline void ImagesWithAreaReply_Data::set_pixels(int64_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImagesWithAreaReply.Data.pixels)
}

// double area = 3 [json_name = "area"];
inline void ImagesWithAreaReply_Data::clear_area() {
  _impl_.area_ = 0;
}
inline double ImagesWithAreaReply_Data::_internal_area() const {
  return _impl_.area_;
}
inline double ImagesWithAreaReply_Data::area() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaReply.Data.area)
  return _internal_area();
}
inline void ImagesWithAreaReply_Data::_internal_set_area(double value) {
  
  _impl_.area_ = value;
}
inline void ImagesWithAreaReply_Data::set_area(double value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImagesWithAreaReply.Data.area)
}

// -------------------------------------------------------------------

// ImagesWithAreaReply

// repeated .htpp.capture.service.v1.ImagesWithAreaReply.Data data = 1 [json_name = "data"];
inline int ImagesWithAreaReply::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int ImagesWithAreaReply::data_size() const {
  return _internal_data_size();
}
inline void ImagesWithAreaReply::clear_data() {
  _impl_.data_.Clear();
}
inline ::htpp::capture::service::v1::ImagesWithAreaReply_Data* ImagesWithAreaReply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesWithAreaReply.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaReply_Data >*
ImagesWithAreaReply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:htpp.capture.service.v1.ImagesWithAreaReply.data)
  return &_impl_.data_;
}
inline const ::htpp::capture::service::v1::ImagesWithAreaReply_Data& ImagesWithAreaReply::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::htpp::capture::service::v1::ImagesWithAreaReply_Data& ImagesWithAreaReply::data(int index) const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaReply.data)
  return _internal_data(index);
}
inline ::htpp::capture::service::v1::ImagesWithAreaReply_Data* ImagesWithAreaReply::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::htpp::capture::service::v1::ImagesWithAreaReply_Data* ImagesWithAreaReply::add_data() {
  ::htpp::capture::service::v1::ImagesWithAreaReply_Data* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:htpp.capture.service.v1.ImagesWithAreaReply.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaReply_Data >&
ImagesWithAreaReply::data() const {
  // @@protoc_insertion_point(field_list:htpp.capture.service.v1.ImagesWithAreaReply.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// ImagesWithAreaAndSrcReply_Data

// .htpp.capture.service.v1.ImageSrc image_src = 1 [json_name = "imageSrc"];
inline bool ImagesWithAreaAndSrcReply_Data::_internal_has_image_src() const {
  return this != internal_default_instance() && _impl_.image_src_ != nullptr;
}
inline bool ImagesWithAreaAndSrcReply_Data::has_image_src() const {
  return _internal_has_image_src();
}
inline void ImagesWithAreaAndSrcReply_Data::clear_image_src() {
  if (GetArenaForAllocation() == nullptr && _impl_.image_src_ != nullptr) {
    delete _impl_.image_src_;
  }
  _impl_.image_src_ = nullptr;
}
inline const ::htpp::capture::service::v1::ImageSrc& ImagesWithAreaAndSrcReply_Data::_internal_image_src() const {
  const ::htpp::capture::service::v1::ImageSrc* p = _impl_.image_src_;
  return p != nullptr ? *p : reinterpret_cast<const ::htpp::capture::service::v1::ImageSrc&>(
      ::htpp::capture::service::v1::_ImageSrc_default_instance_);
}
inline const ::htpp::capture::service::v1::ImageSrc& ImagesWithAreaAndSrcReply_Data::image_src() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.image_src)
  return _internal_image_src();
}
inline void ImagesWithAreaAndSrcReply_Data::unsafe_arena_set_allocated_image_src(
    ::htpp::capture::service::v1::ImageSrc* image_src) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_src_);
  }
  _impl_.image_src_ = image_src;
  if (image_src) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.image_src)
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithAreaAndSrcReply_Data::release_image_src() {
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithAreaAndSrcReply_Data::unsafe_arena_release_image_src() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.image_src)
  
  ::htpp::capture::service::v1::ImageSrc* temp = _impl_.image_src_;
  _impl_.image_src_ = nullptr;
  return temp;
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithAreaAndSrcReply_Data::_internal_mutable_image_src() {
  
  if (_impl_.image_src_ == nullptr) {
    auto* p = CreateMaybeMessage<::htpp::capture::service::v1::ImageSrc>(GetArenaForAllocation());
    _impl_.image_src_ = p;
  }
  return _impl_.image_src_;
}
inline ::htpp::capture::service::v1::ImageSrc* ImagesWithAreaAndSrcReply_Data::mutable_image_src() {
  ::htpp::capture::service::v1::ImageSrc* _msg = _internal_mutable_image_src();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.image_src)
  return _msg;
}
inline void ImagesWithAreaAndSrcReply_Data::set_allocated_image_src(::htpp::capture::service::v1::ImageSrc* image_src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.image_src_;
  }
  if (image_src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_src);
    if (message_arena != submessage_arena) {
      image_src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_src, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.image_src_ = image_src;
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.image_src)
}

// int64 pixels = 2 [json_name = "pixels"];
inline void ImagesWithAreaAndSrcReply_Data::clear_pixels() {
  _impl_.pixels_ = int64_t{0};
}
inline int64_t ImagesWithAreaAndSrcReply_Data::_internal_pixels() const {
  return _impl_.pixels_;
}
inline int64_t ImagesWithAreaAndSrcReply_Data::pixels() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.pixels)
  return _internal_pixels();
}
inline void ImagesWithAreaAndSrcReply_Data::_internal_set_pixels(int64_t value) {
  
  _impl_.pixels_ = value;
}
inline void ImagesWithAreaAndSrcReply_Data::set_pixels(int64_t value) {
  _internal_set_pixels(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.pixels)
}

// double area = 3 [json_name = "area"];
inline void ImagesWithAreaAndSrcReply_Data::clear_area() {
  _impl_.area_ = 0;
}
inline double ImagesWithAreaAndSrcReply_Data::_internal_area() const {
  return _impl_.area_;
}
inline double ImagesWithAreaAndSrcReply_Data::area() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.area)
  return _internal_area();
}
inline void ImagesWithAreaAndSrcReply_Data::_internal_set_area(double value) {
  
  _impl_.area_ = value;
}
inline void ImagesWithAreaAndSrcReply_Data::set_area(double value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data.area)
}

// -------------------------------------------------------------------

// ImagesWithAreaAndSrcReply

// repeated .htpp.capture.service.v1.ImagesWithAreaAndSrcReply.Data data = 1 [json_name = "data"];
inline int ImagesWithAreaAndSrcReply::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int ImagesWithAreaAndSrcReply::data_size() const {
  return _internal_data_size();
}
inline void ImagesWithAreaAndSrcReply::clear_data() {
  _impl_.data_.Clear();
}
inline ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* ImagesWithAreaAndSrcReply::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data >*
ImagesWithAreaAndSrcReply::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.data)
  return &_impl_.data_;
}
inline const ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data& ImagesWithAreaAndSrcReply::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data& ImagesWithAreaAndSrcReply::data(int index) const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.data)
  return _internal_data(index);
}
inline ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* ImagesWithAreaAndSrcReply::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* ImagesWithAreaAndSrcReply::add_data() {
  ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::htpp::capture::service::v1::ImagesWithAreaAndSrcReply_Data >&
ImagesWithAreaAndSrcReply::data() const {
  // @@protoc_insertion_point(field_list:htpp.capture.service.v1.ImagesWithAreaAndSrcReply.data)
  return _impl_.data_;
}

// -------------------------------------------------------------------

// Image

// bytes data = 1 [json_name = "data"];
inline void Image::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.Image.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.Image.data)
}
inline std::string* Image::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.Image.data)
  return _s;
}
inline const std::string& Image::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Image::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.Image.data)
  return _impl_.data_.Release();
}
inline void Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.Image.data)
}

// -------------------------------------------------------------------

// ImageSrc

// bytes proc = 1 [json_name = "proc"];
inline void ImageSrc::clear_proc() {
  _impl_.proc_.ClearToEmpty();
}
inline const std::string& ImageSrc::proc() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageSrc.proc)
  return _internal_proc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSrc::set_proc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.proc_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageSrc.proc)
}
inline std::string* ImageSrc::mutable_proc() {
  std::string* _s = _internal_mutable_proc();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageSrc.proc)
  return _s;
}
inline const std::string& ImageSrc::_internal_proc() const {
  return _impl_.proc_.Get();
}
inline void ImageSrc::_internal_set_proc(const std::string& value) {
  
  _impl_.proc_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSrc::_internal_mutable_proc() {
  
  return _impl_.proc_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSrc::release_proc() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageSrc.proc)
  return _impl_.proc_.Release();
}
inline void ImageSrc::set_allocated_proc(std::string* proc) {
  if (proc != nullptr) {
    
  } else {
    
  }
  _impl_.proc_.SetAllocated(proc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.proc_.IsDefault()) {
    _impl_.proc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageSrc.proc)
}

// bytes src = 2 [json_name = "src"];
inline void ImageSrc::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& ImageSrc::src() const {
  // @@protoc_insertion_point(field_get:htpp.capture.service.v1.ImageSrc.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageSrc::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:htpp.capture.service.v1.ImageSrc.src)
}
inline std::string* ImageSrc::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:htpp.capture.service.v1.ImageSrc.src)
  return _s;
}
inline const std::string& ImageSrc::_internal_src() const {
  return _impl_.src_.Get();
}
inline void ImageSrc::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* ImageSrc::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* ImageSrc::release_src() {
  // @@protoc_insertion_point(field_release:htpp.capture.service.v1.ImageSrc.src)
  return _impl_.src_.Release();
}
inline void ImageSrc::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:htpp.capture.service.v1.ImageSrc.src)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace service
}  // namespace capture
}  // namespace htpp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_apis_2fhtpp_2fcapture_2fservice_2fv1_2fcapture_2eproto
