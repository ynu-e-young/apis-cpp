// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: apis/htpp/machine/service/v1/machine.proto

#include "apis/htpp/machine/service/v1/machine.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace htpp {
namespace machine {
namespace service {
namespace v1 {
PROTOBUF_CONSTEXPR FindByUserIdRequest::FindByUserIdRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FindByUserIdRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FindByUserIdRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FindByUserIdRequestDefaultTypeInternal() {}
  union {
    FindByUserIdRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FindByUserIdRequestDefaultTypeInternal _FindByUserIdRequest_default_instance_;
PROTOBUF_CONSTEXPR CreateRequest::CreateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateRequestDefaultTypeInternal() {}
  union {
    CreateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateRequestDefaultTypeInternal _CreateRequest_default_instance_;
PROTOBUF_CONSTEXPR UpdateRequest::UpdateRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateRequestDefaultTypeInternal() {}
  union {
    UpdateRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateRequestDefaultTypeInternal _UpdateRequest_default_instance_;
PROTOBUF_CONSTEXPR GetRequest::GetRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetRequestDefaultTypeInternal() {}
  union {
    GetRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetRequestDefaultTypeInternal _GetRequest_default_instance_;
PROTOBUF_CONSTEXPR MoveRequest::MoveRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.check_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.rx_)*/0
  , /*decltype(_impl_.ry_)*/0
  , /*decltype(_impl_.delay_)*/0
  , /*decltype(_impl_.check_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveRequestDefaultTypeInternal() {}
  union {
    MoveRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveRequestDefaultTypeInternal _MoveRequest_default_instance_;
PROTOBUF_CONSTEXPR MoveReply::MoveReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveReplyDefaultTypeInternal() {}
  union {
    MoveReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveReplyDefaultTypeInternal _MoveReply_default_instance_;
PROTOBUF_CONSTEXPR MachineReply::MachineReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MachineReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MachineReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MachineReplyDefaultTypeInternal() {}
  union {
    MachineReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MachineReplyDefaultTypeInternal _MachineReply_default_instance_;
PROTOBUF_CONSTEXPR MachinesReply::MachinesReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machines_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MachinesReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MachinesReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MachinesReplyDefaultTypeInternal() {}
  union {
    MachinesReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MachinesReplyDefaultTypeInternal _MachinesReply_default_instance_;
PROTOBUF_CONSTEXPR MachineStruct::MachineStruct(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.user_id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MachineStructDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MachineStructDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MachineStructDefaultTypeInternal() {}
  union {
    MachineStruct _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MachineStructDefaultTypeInternal _MachineStruct_default_instance_;
PROTOBUF_CONSTEXPR ZeroRequest::ZeroRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ZeroRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ZeroRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ZeroRequestDefaultTypeInternal() {}
  union {
    ZeroRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ZeroRequestDefaultTypeInternal _ZeroRequest_default_instance_;
PROTOBUF_CONSTEXPR ZeroReply::ZeroReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ZeroReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ZeroReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ZeroReplyDefaultTypeInternal() {}
  union {
    ZeroReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ZeroReplyDefaultTypeInternal _ZeroReply_default_instance_;
PROTOBUF_CONSTEXPR GetMotorStatusRequest::GetMotorStatusRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetMotorStatusRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetMotorStatusRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetMotorStatusRequestDefaultTypeInternal() {}
  union {
    GetMotorStatusRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetMotorStatusRequestDefaultTypeInternal _GetMotorStatusRequest_default_instance_;
PROTOBUF_CONSTEXPR GetMotorStatusReply::GetMotorStatusReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.motor_info_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetMotorStatusReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetMotorStatusReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetMotorStatusReplyDefaultTypeInternal() {}
  union {
    GetMotorStatusReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetMotorStatusReplyDefaultTypeInternal _GetMotorStatusReply_default_instance_;
PROTOBUF_CONSTEXPR MotorInfo::MotorInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.motor_status_)*/nullptr
  , /*decltype(_impl_.instr_pos_)*/int64_t{0}
  , /*decltype(_impl_.current_pos_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MotorInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotorInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotorInfoDefaultTypeInternal() {}
  union {
    MotorInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotorInfoDefaultTypeInternal _MotorInfo_default_instance_;
PROTOBUF_CONSTEXPR MotorStatus::MotorStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fault_)*/false
  , /*decltype(_impl_.enabling_)*/false
  , /*decltype(_impl_.running_)*/false
  , /*decltype(_impl_.instruction_completion_)*/false
  , /*decltype(_impl_.path_completion_)*/false
  , /*decltype(_impl_.zero_completion_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MotorStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MotorStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MotorStatusDefaultTypeInternal() {}
  union {
    MotorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MotorStatusDefaultTypeInternal _MotorStatus_default_instance_;
PROTOBUF_CONSTEXPR MoveDoneRequest::MoveDoneRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.uuid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.check_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.rx_)*/0
  , /*decltype(_impl_.ry_)*/0
  , /*decltype(_impl_.delay_)*/0
  , /*decltype(_impl_.check_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveDoneRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDoneRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDoneRequestDefaultTypeInternal() {}
  union {
    MoveDoneRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDoneRequestDefaultTypeInternal _MoveDoneRequest_default_instance_;
PROTOBUF_CONSTEXPR MoveDoneReply::MoveDoneReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MoveDoneReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MoveDoneReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MoveDoneReplyDefaultTypeInternal() {}
  union {
    MoveDoneReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MoveDoneReplyDefaultTypeInternal _MoveDoneReply_default_instance_;
PROTOBUF_CONSTEXPR CreateCronJobRequest::CreateCronJobRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cron_job_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CreateCronJobRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CreateCronJobRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CreateCronJobRequestDefaultTypeInternal() {}
  union {
    CreateCronJobRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreateCronJobRequestDefaultTypeInternal _CreateCronJobRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteCronJobRequest::DeleteCronJobRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteCronJobRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteCronJobRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteCronJobRequestDefaultTypeInternal() {}
  union {
    DeleteCronJobRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteCronJobRequestDefaultTypeInternal _DeleteCronJobRequest_default_instance_;
PROTOBUF_CONSTEXPR DeleteCronJobReply::DeleteCronJobReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.num_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DeleteCronJobReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DeleteCronJobReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DeleteCronJobReplyDefaultTypeInternal() {}
  union {
    DeleteCronJobReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeleteCronJobReplyDefaultTypeInternal _DeleteCronJobReply_default_instance_;
PROTOBUF_CONSTEXPR ListCronJobRequest::ListCronJobRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ListCronJobRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ListCronJobRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ListCronJobRequestDefaultTypeInternal() {}
  union {
    ListCronJobRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListCronJobRequestDefaultTypeInternal _ListCronJobRequest_default_instance_;
PROTOBUF_CONSTEXPR CronJobReply::CronJobReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cron_job_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CronJobReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CronJobReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CronJobReplyDefaultTypeInternal() {}
  union {
    CronJobReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CronJobReplyDefaultTypeInternal _CronJobReply_default_instance_;
PROTOBUF_CONSTEXPR CronJobsReply::CronJobsReply(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cron_jobs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CronJobsReplyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CronJobsReplyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CronJobsReplyDefaultTypeInternal() {}
  union {
    CronJobsReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CronJobsReplyDefaultTypeInternal _CronJobsReply_default_instance_;
PROTOBUF_CONSTEXPR CronJob::CronJob(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.check_coordinates_)*/{}
  , /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.check_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cron_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CronJobDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CronJobDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CronJobDefaultTypeInternal() {}
  union {
    CronJob _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CronJobDefaultTypeInternal _CronJob_default_instance_;
PROTOBUF_CONSTEXPR CheckCoordinate::CheckCoordinate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.crd_)*/nullptr
  , /*decltype(_impl_.seq_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckCoordinateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckCoordinateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckCoordinateDefaultTypeInternal() {}
  union {
    CheckCoordinate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckCoordinateDefaultTypeInternal _CheckCoordinate_default_instance_;
PROTOBUF_CONSTEXPR Coordinate::Coordinate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.machine_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.check_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.rx_)*/0
  , /*decltype(_impl_.ry_)*/0
  , /*decltype(_impl_.delay_)*/0
  , /*decltype(_impl_.check_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CoordinateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoordinateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoordinateDefaultTypeInternal() {}
  union {
    Coordinate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoordinateDefaultTypeInternal _Coordinate_default_instance_;
}  // namespace v1
}  // namespace service
}  // namespace machine
}  // namespace htpp
static ::_pb::Metadata file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[26];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto = nullptr;

const uint32_t TableStruct_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::FindByUserIdRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::FindByUserIdRequest, _impl_.user_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CreateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CreateRequest, _impl_.machine_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::UpdateRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::UpdateRequest, _impl_.machine_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetRequest, _impl_.machine_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.rx_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.ry_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.check_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.machine_id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveRequest, _impl_.check_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveReply, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineReply, _impl_.machine_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachinesReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachinesReply, _impl_.machines_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineStruct, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineStruct, _impl_.machine_id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineStruct, _impl_.user_id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MachineStruct, _impl_.address_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ZeroRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ZeroRequest, _impl_.machine_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ZeroReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ZeroReply, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetMotorStatusRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetMotorStatusRequest, _impl_.machine_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetMotorStatusReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::GetMotorStatusReply, _impl_.motor_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorInfo, _impl_.motor_status_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorInfo, _impl_.instr_pos_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorInfo, _impl_.current_pos_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.fault_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.enabling_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.running_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.instruction_completion_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.path_completion_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MotorStatus, _impl_.zero_completion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.rx_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.ry_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.check_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.uuid_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneRequest, _impl_.check_name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::MoveDoneReply, _impl_.status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CreateCronJobRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CreateCronJobRequest, _impl_.cron_job_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::DeleteCronJobRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::DeleteCronJobRequest, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::DeleteCronJobReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::DeleteCronJobReply, _impl_.num_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ListCronJobRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::ListCronJobRequest, _impl_.machine_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJobReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJobReply, _impl_.cron_job_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJobsReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJobsReply, _impl_.cron_jobs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _impl_.machine_id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _impl_.check_name_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _impl_.cron_string_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CronJob, _impl_.check_coordinates_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CheckCoordinate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CheckCoordinate, _impl_.seq_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::CheckCoordinate, _impl_.crd_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.rx_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.ry_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.check_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.machine_id_),
  PROTOBUF_FIELD_OFFSET(::htpp::machine::service::v1::Coordinate, _impl_.check_name_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::htpp::machine::service::v1::FindByUserIdRequest)},
  { 7, -1, -1, sizeof(::htpp::machine::service::v1::CreateRequest)},
  { 14, -1, -1, sizeof(::htpp::machine::service::v1::UpdateRequest)},
  { 21, -1, -1, sizeof(::htpp::machine::service::v1::GetRequest)},
  { 28, -1, -1, sizeof(::htpp::machine::service::v1::MoveRequest)},
  { 43, -1, -1, sizeof(::htpp::machine::service::v1::MoveReply)},
  { 50, -1, -1, sizeof(::htpp::machine::service::v1::MachineReply)},
  { 57, -1, -1, sizeof(::htpp::machine::service::v1::MachinesReply)},
  { 64, -1, -1, sizeof(::htpp::machine::service::v1::MachineStruct)},
  { 73, -1, -1, sizeof(::htpp::machine::service::v1::ZeroRequest)},
  { 80, -1, -1, sizeof(::htpp::machine::service::v1::ZeroReply)},
  { 87, -1, -1, sizeof(::htpp::machine::service::v1::GetMotorStatusRequest)},
  { 94, -1, -1, sizeof(::htpp::machine::service::v1::GetMotorStatusReply)},
  { 101, -1, -1, sizeof(::htpp::machine::service::v1::MotorInfo)},
  { 110, -1, -1, sizeof(::htpp::machine::service::v1::MotorStatus)},
  { 122, -1, -1, sizeof(::htpp::machine::service::v1::MoveDoneRequest)},
  { 137, -1, -1, sizeof(::htpp::machine::service::v1::MoveDoneReply)},
  { 144, -1, -1, sizeof(::htpp::machine::service::v1::CreateCronJobRequest)},
  { 151, -1, -1, sizeof(::htpp::machine::service::v1::DeleteCronJobRequest)},
  { 158, -1, -1, sizeof(::htpp::machine::service::v1::DeleteCronJobReply)},
  { 165, -1, -1, sizeof(::htpp::machine::service::v1::ListCronJobRequest)},
  { 172, -1, -1, sizeof(::htpp::machine::service::v1::CronJobReply)},
  { 179, -1, -1, sizeof(::htpp::machine::service::v1::CronJobsReply)},
  { 186, -1, -1, sizeof(::htpp::machine::service::v1::CronJob)},
  { 197, -1, -1, sizeof(::htpp::machine::service::v1::CheckCoordinate)},
  { 205, -1, -1, sizeof(::htpp::machine::service::v1::Coordinate)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::htpp::machine::service::v1::_FindByUserIdRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_CreateRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_UpdateRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_GetRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_MoveRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_MoveReply_default_instance_._instance,
  &::htpp::machine::service::v1::_MachineReply_default_instance_._instance,
  &::htpp::machine::service::v1::_MachinesReply_default_instance_._instance,
  &::htpp::machine::service::v1::_MachineStruct_default_instance_._instance,
  &::htpp::machine::service::v1::_ZeroRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_ZeroReply_default_instance_._instance,
  &::htpp::machine::service::v1::_GetMotorStatusRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_GetMotorStatusReply_default_instance_._instance,
  &::htpp::machine::service::v1::_MotorInfo_default_instance_._instance,
  &::htpp::machine::service::v1::_MotorStatus_default_instance_._instance,
  &::htpp::machine::service::v1::_MoveDoneRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_MoveDoneReply_default_instance_._instance,
  &::htpp::machine::service::v1::_CreateCronJobRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_DeleteCronJobRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_DeleteCronJobReply_default_instance_._instance,
  &::htpp::machine::service::v1::_ListCronJobRequest_default_instance_._instance,
  &::htpp::machine::service::v1::_CronJobReply_default_instance_._instance,
  &::htpp::machine::service::v1::_CronJobsReply_default_instance_._instance,
  &::htpp::machine::service::v1::_CronJob_default_instance_._instance,
  &::htpp::machine::service::v1::_CheckCoordinate_default_instance_._instance,
  &::htpp::machine::service::v1::_Coordinate_default_instance_._instance,
};

const char descriptor_table_protodef_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n*apis/htpp/machine/service/v1/machine.p"
  "roto\022\027htpp.machine.service.v1\".\n\023FindByU"
  "serIdRequest\022\027\n\007user_id\030\001 \001(\003R\006userId\"Q\n"
  "\rCreateRequest\022@\n\007machine\030\001 \001(\0132&.htpp.m"
  "achine.service.v1.MachineStructR\007machine"
  "\"Q\n\rUpdateRequest\022@\n\007machine\030\001 \001(\0132&.htp"
  "p.machine.service.v1.MachineStructR\007mach"
  "ine\"+\n\nGetRequest\022\035\n\nmachine_id\030\001 \001(\tR\tm"
  "achineId\"\301\001\n\013MoveRequest\022\014\n\001x\030\001 \001(\001R\001x\022\014"
  "\n\001y\030\002 \001(\001R\001y\022\014\n\001z\030\003 \001(\001R\001z\022\016\n\002rx\030\004 \001(\001R\002"
  "rx\022\016\n\002ry\030\005 \001(\001R\002ry\022\024\n\005check\030\006 \001(\010R\005check"
  "\022\024\n\005delay\030\007 \001(\001R\005delay\022\035\n\nmachine_id\030\010 \001"
  "(\tR\tmachineId\022\035\n\ncheck_name\030\t \001(\tR\tcheck"
  "Name\"#\n\tMoveReply\022\026\n\006status\030\001 \001(\010R\006statu"
  "s\"P\n\014MachineReply\022@\n\007machine\030\001 \001(\0132&.htp"
  "p.machine.service.v1.MachineStructR\007mach"
  "ine\"S\n\rMachinesReply\022B\n\010machines\030\001 \003(\0132&"
  ".htpp.machine.service.v1.MachineStructR\010"
  "machines\"a\n\rMachineStruct\022\035\n\nmachine_id\030"
  "\001 \001(\tR\tmachineId\022\027\n\007user_id\030\002 \001(\003R\006userI"
  "d\022\030\n\007address\030\003 \001(\tR\007address\",\n\013ZeroReque"
  "st\022\035\n\nmachine_id\030\001 \001(\tR\tmachineId\"#\n\tZer"
  "oReply\022\026\n\006status\030\001 \001(\010R\006status\"6\n\025GetMot"
  "orStatusRequest\022\035\n\nmachine_id\030\001 \001(\tR\tmac"
  "hineId\"X\n\023GetMotorStatusReply\022A\n\nmotor_i"
  "nfo\030\001 \003(\0132\".htpp.machine.service.v1.Moto"
  "rInfoR\tmotorInfo\"\222\001\n\tMotorInfo\022G\n\014motor_"
  "status\030\001 \001(\0132$.htpp.machine.service.v1.M"
  "otorStatusR\013motorStatus\022\033\n\tinstr_pos\030\002 \001"
  "(\003R\010instrPos\022\037\n\013current_pos\030\003 \001(\003R\ncurre"
  "ntPos\"\342\001\n\013MotorStatus\022\024\n\005fault\030\001 \001(\010R\005fa"
  "ult\022\032\n\010enabling\030\002 \001(\010R\010enabling\022\030\n\007runni"
  "ng\030\003 \001(\010R\007running\0225\n\026instruction_complet"
  "ion\030\004 \001(\010R\025instructionCompletion\022\'\n\017path"
  "_completion\030\005 \001(\010R\016pathCompletion\022\'\n\017zer"
  "o_completion\030\006 \001(\010R\016zeroCompletion\"\272\001\n\017M"
  "oveDoneRequest\022\014\n\001x\030\001 \001(\001R\001x\022\014\n\001y\030\002 \001(\001R"
  "\001y\022\014\n\001z\030\003 \001(\001R\001z\022\016\n\002rx\030\004 \001(\001R\002rx\022\016\n\002ry\030\005"
  " \001(\001R\002ry\022\024\n\005check\030\006 \001(\010R\005check\022\024\n\005delay\030"
  "\007 \001(\001R\005delay\022\022\n\004uuid\030\010 \001(\tR\004uuid\022\035\n\nchec"
  "k_name\030\t \001(\tR\tcheckName\"\'\n\rMoveDoneReply"
  "\022\026\n\006status\030\001 \001(\010R\006status\"S\n\024CreateCronJo"
  "bRequest\022;\n\010cron_job\030\001 \001(\0132 .htpp.machin"
  "e.service.v1.CronJobR\007cronJob\"&\n\024DeleteC"
  "ronJobRequest\022\016\n\002id\030\001 \001(\003R\002id\"&\n\022DeleteC"
  "ronJobReply\022\020\n\003num\030\001 \001(\003R\003num\"3\n\022ListCro"
  "nJobRequest\022\035\n\nmachine_id\030\001 \001(\tR\tmachine"
  "Id\"K\n\014CronJobReply\022;\n\010cron_job\030\001 \001(\0132 .h"
  "tpp.machine.service.v1.CronJobR\007cronJob\""
  "N\n\rCronJobsReply\022=\n\tcron_jobs\030\001 \003(\0132 .ht"
  "pp.machine.service.v1.CronJobR\010cronJobs\""
  "\317\001\n\007CronJob\022\016\n\002id\030\001 \001(\003R\002id\022\035\n\nmachine_i"
  "d\030\002 \001(\tR\tmachineId\022\035\n\ncheck_name\030\003 \001(\tR\t"
  "checkName\022\037\n\013cron_string\030\004 \001(\tR\ncronStri"
  "ng\022U\n\021check_coordinates\030\005 \003(\0132(.htpp.mac"
  "hine.service.v1.CheckCoordinateR\020checkCo"
  "ordinates\"Z\n\017CheckCoordinate\022\020\n\003seq\030\001 \001("
  "\003R\003seq\0225\n\003crd\030\002 \001(\0132#.htpp.machine.servi"
  "ce.v1.CoordinateR\003crd\"\300\001\n\nCoordinate\022\014\n\001"
  "x\030\001 \001(\001R\001x\022\014\n\001y\030\002 \001(\001R\001y\022\014\n\001z\030\003 \001(\001R\001z\022\016"
  "\n\002rx\030\004 \001(\001R\002rx\022\016\n\002ry\030\005 \001(\001R\002ry\022\024\n\005check\030"
  "\006 \001(\010R\005check\022\024\n\005delay\030\007 \001(\001R\005delay\022\035\n\nma"
  "chine_id\030\010 \001(\tR\tmachineId\022\035\n\ncheck_name\030"
  "\t \001(\tR\tcheckName2\264\010\n\007Machine\022f\n\014FindByUs"
  "erId\022,.htpp.machine.service.v1.FindByUse"
  "rIdRequest\032&.htpp.machine.service.v1.Mac"
  "hinesReply\"\000\022Y\n\006Create\022&.htpp.machine.se"
  "rvice.v1.CreateRequest\032%.htpp.machine.se"
  "rvice.v1.MachineReply\"\000\022Y\n\006Update\022&.htpp"
  ".machine.service.v1.UpdateRequest\032%.htpp"
  ".machine.service.v1.MachineReply\"\000\022S\n\003Ge"
  "t\022#.htpp.machine.service.v1.GetRequest\032%"
  ".htpp.machine.service.v1.MachineReply\"\000\022"
  "R\n\004Move\022$.htpp.machine.service.v1.MoveRe"
  "quest\032\".htpp.machine.service.v1.MoveRepl"
  "y\"\000\022R\n\004Zero\022$.htpp.machine.service.v1.Ze"
  "roRequest\032\".htpp.machine.service.v1.Zero"
  "Reply\"\000\022p\n\016GetMotorStatus\022..htpp.machine"
  ".service.v1.GetMotorStatusRequest\032,.htpp"
  ".machine.service.v1.GetMotorStatusReply\""
  "\000\022^\n\010MoveDone\022(.htpp.machine.service.v1."
  "MoveDoneRequest\032&.htpp.machine.service.v"
  "1.MoveDoneReply\"\000\022g\n\rCreateCronJob\022-.htp"
  "p.machine.service.v1.CreateCronJobReques"
  "t\032%.htpp.machine.service.v1.CronJobReply"
  "\"\000\022m\n\rDeleteCronJob\022-.htpp.machine.servi"
  "ce.v1.DeleteCronJobRequest\032+.htpp.machin"
  "e.service.v1.DeleteCronJobReply\"\000\022d\n\013Lis"
  "tCronJob\022+.htpp.machine.service.v1.ListC"
  "ronJobRequest\032&.htpp.machine.service.v1."
  "CronJobsReply\"\000B\036P\001Z\032htpp/machine/servic"
  "e/v1;v1b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto = {
    false, false, 3655, descriptor_table_protodef_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto,
    "apis/htpp/machine/service/v1/machine.proto",
    &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once, nullptr, 0, 26,
    schemas, file_default_instances, TableStruct_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto::offsets,
    file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto, file_level_enum_descriptors_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto,
    file_level_service_descriptors_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter() {
  return &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto(&descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto);
namespace htpp {
namespace machine {
namespace service {
namespace v1 {

// ===================================================================

class FindByUserIdRequest::_Internal {
 public:
};

FindByUserIdRequest::FindByUserIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.FindByUserIdRequest)
}
FindByUserIdRequest::FindByUserIdRequest(const FindByUserIdRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FindByUserIdRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.FindByUserIdRequest)
}

inline void FindByUserIdRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FindByUserIdRequest::~FindByUserIdRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.FindByUserIdRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FindByUserIdRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FindByUserIdRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FindByUserIdRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.FindByUserIdRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FindByUserIdRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 user_id = 1 [json_name = "userId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FindByUserIdRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.FindByUserIdRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 user_id = 1 [json_name = "userId"];
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.FindByUserIdRequest)
  return target;
}

size_t FindByUserIdRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.FindByUserIdRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 user_id = 1 [json_name = "userId"];
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FindByUserIdRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FindByUserIdRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FindByUserIdRequest::GetClassData() const { return &_class_data_; }


void FindByUserIdRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FindByUserIdRequest*>(&to_msg);
  auto& from = static_cast<const FindByUserIdRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.FindByUserIdRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FindByUserIdRequest::CopyFrom(const FindByUserIdRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.FindByUserIdRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindByUserIdRequest::IsInitialized() const {
  return true;
}

void FindByUserIdRequest::InternalSwap(FindByUserIdRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FindByUserIdRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[0]);
}

// ===================================================================

class CreateRequest::_Internal {
 public:
  static const ::htpp::machine::service::v1::MachineStruct& machine(const CreateRequest* msg);
};

const ::htpp::machine::service::v1::MachineStruct&
CreateRequest::_Internal::machine(const CreateRequest* msg) {
  return *msg->_impl_.machine_;
}
CreateRequest::CreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CreateRequest)
}
CreateRequest::CreateRequest(const CreateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_machine()) {
    _this->_impl_.machine_ = new ::htpp::machine::service::v1::MachineStruct(*from._impl_.machine_);
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CreateRequest)
}

inline void CreateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CreateRequest::~CreateRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CreateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.machine_;
}

void CreateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CreateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.machine_ != nullptr) {
    delete _impl_.machine_;
  }
  _impl_.machine_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_machine(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CreateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::machine(this),
        _Internal::machine(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CreateRequest)
  return target;
}

size_t CreateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CreateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.machine_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateRequest::GetClassData() const { return &_class_data_; }


void CreateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateRequest*>(&to_msg);
  auto& from = static_cast<const CreateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CreateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_machine()) {
    _this->_internal_mutable_machine()->::htpp::machine::service::v1::MachineStruct::MergeFrom(
        from._internal_machine());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateRequest::CopyFrom(const CreateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CreateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRequest::IsInitialized() const {
  return true;
}

void CreateRequest::InternalSwap(CreateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.machine_, other->_impl_.machine_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[1]);
}

// ===================================================================

class UpdateRequest::_Internal {
 public:
  static const ::htpp::machine::service::v1::MachineStruct& machine(const UpdateRequest* msg);
};

const ::htpp::machine::service::v1::MachineStruct&
UpdateRequest::_Internal::machine(const UpdateRequest* msg) {
  return *msg->_impl_.machine_;
}
UpdateRequest::UpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.UpdateRequest)
}
UpdateRequest::UpdateRequest(const UpdateRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_machine()) {
    _this->_impl_.machine_ = new ::htpp::machine::service::v1::MachineStruct(*from._impl_.machine_);
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.UpdateRequest)
}

inline void UpdateRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateRequest::~UpdateRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.UpdateRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.machine_;
}

void UpdateRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.UpdateRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.machine_ != nullptr) {
    delete _impl_.machine_;
  }
  _impl_.machine_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_machine(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.UpdateRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::machine(this),
        _Internal::machine(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.UpdateRequest)
  return target;
}

size_t UpdateRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.UpdateRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.machine_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateRequest::GetClassData() const { return &_class_data_; }


void UpdateRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateRequest*>(&to_msg);
  auto& from = static_cast<const UpdateRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.UpdateRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_machine()) {
    _this->_internal_mutable_machine()->::htpp::machine::service::v1::MachineStruct::MergeFrom(
        from._internal_machine());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateRequest::CopyFrom(const UpdateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.UpdateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateRequest::IsInitialized() const {
  return true;
}

void UpdateRequest::InternalSwap(UpdateRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.machine_, other->_impl_.machine_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[2]);
}

// ===================================================================

class GetRequest::_Internal {
 public:
};

GetRequest::GetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.GetRequest)
}
GetRequest::GetRequest(const GetRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.GetRequest)
}

inline void GetRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetRequest::~GetRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.GetRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
}

void GetRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.GetRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string machine_id = 1 [json_name = "machineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.GetRequest.machine_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.GetRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.GetRequest.machine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.GetRequest)
  return target;
}

size_t GetRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.GetRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetRequest::GetClassData() const { return &_class_data_; }


void GetRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetRequest*>(&to_msg);
  auto& from = static_cast<const GetRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.GetRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetRequest::CopyFrom(const GetRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.GetRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetRequest::IsInitialized() const {
  return true;
}

void GetRequest::InternalSwap(GetRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[3]);
}

// ===================================================================

class MoveRequest::_Internal {
 public:
};

MoveRequest::MoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MoveRequest)
}
MoveRequest::MoveRequest(const MoveRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.rx_){}
    , decltype(_impl_.ry_){}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.check_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_name().empty()) {
    _this->_impl_.check_name_.Set(from._internal_check_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.check_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MoveRequest)
}

inline void MoveRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.rx_){0}
    , decltype(_impl_.ry_){0}
    , decltype(_impl_.delay_){0}
    , decltype(_impl_.check_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoveRequest::~MoveRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MoveRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
  _impl_.check_name_.Destroy();
}

void MoveRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MoveRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _impl_.check_name_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.check_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1 [json_name = "x"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2 [json_name = "y"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3 [json_name = "z"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rx = 4 [json_name = "rx"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.rx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ry = 5 [json_name = "ry"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.ry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool check = 6 [json_name = "check"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.check_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double delay = 7 [json_name = "delay"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string machine_id = 8 [json_name = "machineId"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MoveRequest.machine_id"));
        } else
          goto handle_unusual;
        continue;
      // string check_name = 9 [json_name = "checkName"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_check_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MoveRequest.check_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MoveRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_rx(), target);
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_ry(), target);
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_check(), target);
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_delay(), target);
  }

  // string machine_id = 8 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MoveRequest.machine_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_machine_id(), target);
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_name().data(), static_cast<int>(this->_internal_check_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MoveRequest.check_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_check_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MoveRequest)
  return target;
}

size_t MoveRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MoveRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 8 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_name());
  }

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    total_size += 1 + 8;
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    total_size += 1 + 8;
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    total_size += 1 + 8;
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveRequest::GetClassData() const { return &_class_data_; }


void MoveRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveRequest*>(&to_msg);
  auto& from = static_cast<const MoveRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MoveRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  if (!from._internal_check_name().empty()) {
    _this->_internal_set_check_name(from._internal_check_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = from._internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    _this->_internal_set_rx(from._internal_rx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = from._internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    _this->_internal_set_ry(from._internal_ry());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = from._internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    _this->_internal_set_delay(from._internal_delay());
  }
  if (from._internal_check() != 0) {
    _this->_internal_set_check(from._internal_check());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveRequest::CopyFrom(const MoveRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MoveRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveRequest::IsInitialized() const {
  return true;
}

void MoveRequest::InternalSwap(MoveRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.check_name_, lhs_arena,
      &other->_impl_.check_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveRequest, _impl_.check_)
      + sizeof(MoveRequest::_impl_.check_)
      - PROTOBUF_FIELD_OFFSET(MoveRequest, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[4]);
}

// ===================================================================

class MoveReply::_Internal {
 public:
};

MoveReply::MoveReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MoveReply)
}
MoveReply::MoveReply(const MoveReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MoveReply)
}

inline void MoveReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoveReply::~MoveReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MoveReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MoveReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MoveReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1 [json_name = "status"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MoveReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MoveReply)
  return target;
}

size_t MoveReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MoveReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveReply::GetClassData() const { return &_class_data_; }


void MoveReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveReply*>(&to_msg);
  auto& from = static_cast<const MoveReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MoveReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveReply::CopyFrom(const MoveReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MoveReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveReply::IsInitialized() const {
  return true;
}

void MoveReply::InternalSwap(MoveReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[5]);
}

// ===================================================================

class MachineReply::_Internal {
 public:
  static const ::htpp::machine::service::v1::MachineStruct& machine(const MachineReply* msg);
};

const ::htpp::machine::service::v1::MachineStruct&
MachineReply::_Internal::machine(const MachineReply* msg) {
  return *msg->_impl_.machine_;
}
MachineReply::MachineReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MachineReply)
}
MachineReply::MachineReply(const MachineReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MachineReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_machine()) {
    _this->_impl_.machine_ = new ::htpp::machine::service::v1::MachineStruct(*from._impl_.machine_);
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MachineReply)
}

inline void MachineReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MachineReply::~MachineReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MachineReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MachineReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.machine_;
}

void MachineReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MachineReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MachineReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.machine_ != nullptr) {
    delete _impl_.machine_;
  }
  _impl_.machine_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MachineReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_machine(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MachineReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MachineReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::machine(this),
        _Internal::machine(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MachineReply)
  return target;
}

size_t MachineReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MachineReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MachineStruct machine = 1 [json_name = "machine"];
  if (this->_internal_has_machine()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.machine_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MachineReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MachineReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MachineReply::GetClassData() const { return &_class_data_; }


void MachineReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MachineReply*>(&to_msg);
  auto& from = static_cast<const MachineReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MachineReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_machine()) {
    _this->_internal_mutable_machine()->::htpp::machine::service::v1::MachineStruct::MergeFrom(
        from._internal_machine());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MachineReply::CopyFrom(const MachineReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MachineReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineReply::IsInitialized() const {
  return true;
}

void MachineReply::InternalSwap(MachineReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.machine_, other->_impl_.machine_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MachineReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[6]);
}

// ===================================================================

class MachinesReply::_Internal {
 public:
};

MachinesReply::MachinesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MachinesReply)
}
MachinesReply::MachinesReply(const MachinesReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MachinesReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machines_){from._impl_.machines_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MachinesReply)
}

inline void MachinesReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machines_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MachinesReply::~MachinesReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MachinesReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MachinesReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machines_.~RepeatedPtrField();
}

void MachinesReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MachinesReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MachinesReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machines_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MachinesReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .htpp.machine.service.v1.MachineStruct machines = 1 [json_name = "machines"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_machines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MachinesReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MachinesReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.MachineStruct machines = 1 [json_name = "machines"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_machines_size()); i < n; i++) {
    const auto& repfield = this->_internal_machines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MachinesReply)
  return target;
}

size_t MachinesReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MachinesReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.MachineStruct machines = 1 [json_name = "machines"];
  total_size += 1UL * this->_internal_machines_size();
  for (const auto& msg : this->_impl_.machines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MachinesReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MachinesReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MachinesReply::GetClassData() const { return &_class_data_; }


void MachinesReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MachinesReply*>(&to_msg);
  auto& from = static_cast<const MachinesReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MachinesReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.machines_.MergeFrom(from._impl_.machines_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MachinesReply::CopyFrom(const MachinesReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MachinesReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachinesReply::IsInitialized() const {
  return true;
}

void MachinesReply::InternalSwap(MachinesReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.machines_.InternalSwap(&other->_impl_.machines_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MachinesReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[7]);
}

// ===================================================================

class MachineStruct::_Internal {
 public:
};

MachineStruct::MachineStruct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MachineStruct)
}
MachineStruct::MachineStruct(const MachineStruct& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MachineStruct* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.user_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.user_id_ = from._impl_.user_id_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MachineStruct)
}

inline void MachineStruct::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.user_id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MachineStruct::~MachineStruct() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MachineStruct)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MachineStruct::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
  _impl_.address_.Destroy();
}

void MachineStruct::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MachineStruct::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MachineStruct)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _impl_.address_.ClearToEmpty();
  _impl_.user_id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MachineStruct::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string machine_id = 1 [json_name = "machineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MachineStruct.machine_id"));
        } else
          goto handle_unusual;
        continue;
      // int64 user_id = 2 [json_name = "userId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string address = 3 [json_name = "address"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MachineStruct.address"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MachineStruct::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MachineStruct)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MachineStruct.machine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_id(), target);
  }

  // int64 user_id = 2 [json_name = "userId"];
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_user_id(), target);
  }

  // string address = 3 [json_name = "address"];
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MachineStruct.address");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MachineStruct)
  return target;
}

size_t MachineStruct::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MachineStruct)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  // string address = 3 [json_name = "address"];
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // int64 user_id = 2 [json_name = "userId"];
  if (this->_internal_user_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MachineStruct::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MachineStruct::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MachineStruct::GetClassData() const { return &_class_data_; }


void MachineStruct::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MachineStruct*>(&to_msg);
  auto& from = static_cast<const MachineStruct&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MachineStruct)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (from._internal_user_id() != 0) {
    _this->_internal_set_user_id(from._internal_user_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MachineStruct::CopyFrom(const MachineStruct& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MachineStruct)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineStruct::IsInitialized() const {
  return true;
}

void MachineStruct::InternalSwap(MachineStruct* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  swap(_impl_.user_id_, other->_impl_.user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MachineStruct::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[8]);
}

// ===================================================================

class ZeroRequest::_Internal {
 public:
};

ZeroRequest::ZeroRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.ZeroRequest)
}
ZeroRequest::ZeroRequest(const ZeroRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ZeroRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.ZeroRequest)
}

inline void ZeroRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ZeroRequest::~ZeroRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.ZeroRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ZeroRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
}

void ZeroRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ZeroRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.ZeroRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ZeroRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string machine_id = 1 [json_name = "machineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.ZeroRequest.machine_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ZeroRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.ZeroRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.ZeroRequest.machine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.ZeroRequest)
  return target;
}

size_t ZeroRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.ZeroRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ZeroRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ZeroRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ZeroRequest::GetClassData() const { return &_class_data_; }


void ZeroRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ZeroRequest*>(&to_msg);
  auto& from = static_cast<const ZeroRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.ZeroRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ZeroRequest::CopyFrom(const ZeroRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.ZeroRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZeroRequest::IsInitialized() const {
  return true;
}

void ZeroRequest::InternalSwap(ZeroRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ZeroRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[9]);
}

// ===================================================================

class ZeroReply::_Internal {
 public:
};

ZeroReply::ZeroReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.ZeroReply)
}
ZeroReply::ZeroReply(const ZeroReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ZeroReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.ZeroReply)
}

inline void ZeroReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ZeroReply::~ZeroReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.ZeroReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ZeroReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ZeroReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ZeroReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.ZeroReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ZeroReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1 [json_name = "status"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ZeroReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.ZeroReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.ZeroReply)
  return target;
}

size_t ZeroReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.ZeroReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ZeroReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ZeroReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ZeroReply::GetClassData() const { return &_class_data_; }


void ZeroReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ZeroReply*>(&to_msg);
  auto& from = static_cast<const ZeroReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.ZeroReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ZeroReply::CopyFrom(const ZeroReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.ZeroReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZeroReply::IsInitialized() const {
  return true;
}

void ZeroReply::InternalSwap(ZeroReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ZeroReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[10]);
}

// ===================================================================

class GetMotorStatusRequest::_Internal {
 public:
};

GetMotorStatusRequest::GetMotorStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.GetMotorStatusRequest)
}
GetMotorStatusRequest::GetMotorStatusRequest(const GetMotorStatusRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetMotorStatusRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.GetMotorStatusRequest)
}

inline void GetMotorStatusRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetMotorStatusRequest::~GetMotorStatusRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.GetMotorStatusRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetMotorStatusRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
}

void GetMotorStatusRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetMotorStatusRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.GetMotorStatusRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMotorStatusRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string machine_id = 1 [json_name = "machineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.GetMotorStatusRequest.machine_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMotorStatusRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.GetMotorStatusRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.GetMotorStatusRequest.machine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.GetMotorStatusRequest)
  return target;
}

size_t GetMotorStatusRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.GetMotorStatusRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMotorStatusRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetMotorStatusRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMotorStatusRequest::GetClassData() const { return &_class_data_; }


void GetMotorStatusRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetMotorStatusRequest*>(&to_msg);
  auto& from = static_cast<const GetMotorStatusRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.GetMotorStatusRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMotorStatusRequest::CopyFrom(const GetMotorStatusRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.GetMotorStatusRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMotorStatusRequest::IsInitialized() const {
  return true;
}

void GetMotorStatusRequest::InternalSwap(GetMotorStatusRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMotorStatusRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[11]);
}

// ===================================================================

class GetMotorStatusReply::_Internal {
 public:
};

GetMotorStatusReply::GetMotorStatusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.GetMotorStatusReply)
}
GetMotorStatusReply::GetMotorStatusReply(const GetMotorStatusReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetMotorStatusReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.motor_info_){from._impl_.motor_info_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.GetMotorStatusReply)
}

inline void GetMotorStatusReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.motor_info_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetMotorStatusReply::~GetMotorStatusReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.GetMotorStatusReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetMotorStatusReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.motor_info_.~RepeatedPtrField();
}

void GetMotorStatusReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetMotorStatusReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.GetMotorStatusReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.motor_info_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetMotorStatusReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .htpp.machine.service.v1.MotorInfo motor_info = 1 [json_name = "motorInfo"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_motor_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetMotorStatusReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.GetMotorStatusReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.MotorInfo motor_info = 1 [json_name = "motorInfo"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_motor_info_size()); i < n; i++) {
    const auto& repfield = this->_internal_motor_info(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.GetMotorStatusReply)
  return target;
}

size_t GetMotorStatusReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.GetMotorStatusReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.MotorInfo motor_info = 1 [json_name = "motorInfo"];
  total_size += 1UL * this->_internal_motor_info_size();
  for (const auto& msg : this->_impl_.motor_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetMotorStatusReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetMotorStatusReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetMotorStatusReply::GetClassData() const { return &_class_data_; }


void GetMotorStatusReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetMotorStatusReply*>(&to_msg);
  auto& from = static_cast<const GetMotorStatusReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.GetMotorStatusReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.motor_info_.MergeFrom(from._impl_.motor_info_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetMotorStatusReply::CopyFrom(const GetMotorStatusReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.GetMotorStatusReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMotorStatusReply::IsInitialized() const {
  return true;
}

void GetMotorStatusReply::InternalSwap(GetMotorStatusReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.motor_info_.InternalSwap(&other->_impl_.motor_info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetMotorStatusReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[12]);
}

// ===================================================================

class MotorInfo::_Internal {
 public:
  static const ::htpp::machine::service::v1::MotorStatus& motor_status(const MotorInfo* msg);
};

const ::htpp::machine::service::v1::MotorStatus&
MotorInfo::_Internal::motor_status(const MotorInfo* msg) {
  return *msg->_impl_.motor_status_;
}
MotorInfo::MotorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MotorInfo)
}
MotorInfo::MotorInfo(const MotorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MotorInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.motor_status_){nullptr}
    , decltype(_impl_.instr_pos_){}
    , decltype(_impl_.current_pos_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_motor_status()) {
    _this->_impl_.motor_status_ = new ::htpp::machine::service::v1::MotorStatus(*from._impl_.motor_status_);
  }
  ::memcpy(&_impl_.instr_pos_, &from._impl_.instr_pos_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.current_pos_) -
    reinterpret_cast<char*>(&_impl_.instr_pos_)) + sizeof(_impl_.current_pos_));
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MotorInfo)
}

inline void MotorInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.motor_status_){nullptr}
    , decltype(_impl_.instr_pos_){int64_t{0}}
    , decltype(_impl_.current_pos_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MotorInfo::~MotorInfo() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MotorInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MotorInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.motor_status_;
}

void MotorInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MotorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MotorInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.motor_status_ != nullptr) {
    delete _impl_.motor_status_;
  }
  _impl_.motor_status_ = nullptr;
  ::memset(&_impl_.instr_pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.current_pos_) -
      reinterpret_cast<char*>(&_impl_.instr_pos_)) + sizeof(_impl_.current_pos_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.MotorStatus motor_status = 1 [json_name = "motorStatus"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_motor_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 instr_pos = 2 [json_name = "instrPos"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.instr_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 current_pos = 3 [json_name = "currentPos"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.current_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MotorInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MotorStatus motor_status = 1 [json_name = "motorStatus"];
  if (this->_internal_has_motor_status()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::motor_status(this),
        _Internal::motor_status(this).GetCachedSize(), target, stream);
  }

  // int64 instr_pos = 2 [json_name = "instrPos"];
  if (this->_internal_instr_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_instr_pos(), target);
  }

  // int64 current_pos = 3 [json_name = "currentPos"];
  if (this->_internal_current_pos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_current_pos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MotorInfo)
  return target;
}

size_t MotorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MotorInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.MotorStatus motor_status = 1 [json_name = "motorStatus"];
  if (this->_internal_has_motor_status()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.motor_status_);
  }

  // int64 instr_pos = 2 [json_name = "instrPos"];
  if (this->_internal_instr_pos() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_instr_pos());
  }

  // int64 current_pos = 3 [json_name = "currentPos"];
  if (this->_internal_current_pos() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_current_pos());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MotorInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorInfo::GetClassData() const { return &_class_data_; }


void MotorInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MotorInfo*>(&to_msg);
  auto& from = static_cast<const MotorInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MotorInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_motor_status()) {
    _this->_internal_mutable_motor_status()->::htpp::machine::service::v1::MotorStatus::MergeFrom(
        from._internal_motor_status());
  }
  if (from._internal_instr_pos() != 0) {
    _this->_internal_set_instr_pos(from._internal_instr_pos());
  }
  if (from._internal_current_pos() != 0) {
    _this->_internal_set_current_pos(from._internal_current_pos());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorInfo::CopyFrom(const MotorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MotorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorInfo::IsInitialized() const {
  return true;
}

void MotorInfo::InternalSwap(MotorInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorInfo, _impl_.current_pos_)
      + sizeof(MotorInfo::_impl_.current_pos_)
      - PROTOBUF_FIELD_OFFSET(MotorInfo, _impl_.motor_status_)>(
          reinterpret_cast<char*>(&_impl_.motor_status_),
          reinterpret_cast<char*>(&other->_impl_.motor_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[13]);
}

// ===================================================================

class MotorStatus::_Internal {
 public:
};

MotorStatus::MotorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MotorStatus)
}
MotorStatus::MotorStatus(const MotorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MotorStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fault_){}
    , decltype(_impl_.enabling_){}
    , decltype(_impl_.running_){}
    , decltype(_impl_.instruction_completion_){}
    , decltype(_impl_.path_completion_){}
    , decltype(_impl_.zero_completion_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.fault_, &from._impl_.fault_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.zero_completion_) -
    reinterpret_cast<char*>(&_impl_.fault_)) + sizeof(_impl_.zero_completion_));
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MotorStatus)
}

inline void MotorStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fault_){false}
    , decltype(_impl_.enabling_){false}
    , decltype(_impl_.running_){false}
    , decltype(_impl_.instruction_completion_){false}
    , decltype(_impl_.path_completion_){false}
    , decltype(_impl_.zero_completion_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MotorStatus::~MotorStatus() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MotorStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MotorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MotorStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MotorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MotorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.fault_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.zero_completion_) -
      reinterpret_cast<char*>(&_impl_.fault_)) + sizeof(_impl_.zero_completion_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MotorStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool fault = 1 [json_name = "fault"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.fault_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enabling = 2 [json_name = "enabling"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.enabling_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool running = 3 [json_name = "running"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool instruction_completion = 4 [json_name = "instructionCompletion"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.instruction_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool path_completion = 5 [json_name = "pathCompletion"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.path_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool zero_completion = 6 [json_name = "zeroCompletion"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.zero_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MotorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MotorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fault = 1 [json_name = "fault"];
  if (this->_internal_fault() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_fault(), target);
  }

  // bool enabling = 2 [json_name = "enabling"];
  if (this->_internal_enabling() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enabling(), target);
  }

  // bool running = 3 [json_name = "running"];
  if (this->_internal_running() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_running(), target);
  }

  // bool instruction_completion = 4 [json_name = "instructionCompletion"];
  if (this->_internal_instruction_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_instruction_completion(), target);
  }

  // bool path_completion = 5 [json_name = "pathCompletion"];
  if (this->_internal_path_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_path_completion(), target);
  }

  // bool zero_completion = 6 [json_name = "zeroCompletion"];
  if (this->_internal_zero_completion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_zero_completion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MotorStatus)
  return target;
}

size_t MotorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MotorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool fault = 1 [json_name = "fault"];
  if (this->_internal_fault() != 0) {
    total_size += 1 + 1;
  }

  // bool enabling = 2 [json_name = "enabling"];
  if (this->_internal_enabling() != 0) {
    total_size += 1 + 1;
  }

  // bool running = 3 [json_name = "running"];
  if (this->_internal_running() != 0) {
    total_size += 1 + 1;
  }

  // bool instruction_completion = 4 [json_name = "instructionCompletion"];
  if (this->_internal_instruction_completion() != 0) {
    total_size += 1 + 1;
  }

  // bool path_completion = 5 [json_name = "pathCompletion"];
  if (this->_internal_path_completion() != 0) {
    total_size += 1 + 1;
  }

  // bool zero_completion = 6 [json_name = "zeroCompletion"];
  if (this->_internal_zero_completion() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MotorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MotorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MotorStatus::GetClassData() const { return &_class_data_; }


void MotorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MotorStatus*>(&to_msg);
  auto& from = static_cast<const MotorStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MotorStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_fault() != 0) {
    _this->_internal_set_fault(from._internal_fault());
  }
  if (from._internal_enabling() != 0) {
    _this->_internal_set_enabling(from._internal_enabling());
  }
  if (from._internal_running() != 0) {
    _this->_internal_set_running(from._internal_running());
  }
  if (from._internal_instruction_completion() != 0) {
    _this->_internal_set_instruction_completion(from._internal_instruction_completion());
  }
  if (from._internal_path_completion() != 0) {
    _this->_internal_set_path_completion(from._internal_path_completion());
  }
  if (from._internal_zero_completion() != 0) {
    _this->_internal_set_zero_completion(from._internal_zero_completion());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MotorStatus::CopyFrom(const MotorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MotorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorStatus::IsInitialized() const {
  return true;
}

void MotorStatus::InternalSwap(MotorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MotorStatus, _impl_.zero_completion_)
      + sizeof(MotorStatus::_impl_.zero_completion_)
      - PROTOBUF_FIELD_OFFSET(MotorStatus, _impl_.fault_)>(
          reinterpret_cast<char*>(&_impl_.fault_),
          reinterpret_cast<char*>(&other->_impl_.fault_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MotorStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[14]);
}

// ===================================================================

class MoveDoneRequest::_Internal {
 public:
};

MoveDoneRequest::MoveDoneRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MoveDoneRequest)
}
MoveDoneRequest::MoveDoneRequest(const MoveDoneRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDoneRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.rx_){}
    , decltype(_impl_.ry_){}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.check_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_uuid().empty()) {
    _this->_impl_.uuid_.Set(from._internal_uuid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_name().empty()) {
    _this->_impl_.check_name_.Set(from._internal_check_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.check_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MoveDoneRequest)
}

inline void MoveDoneRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.uuid_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.rx_){0}
    , decltype(_impl_.ry_){0}
    , decltype(_impl_.delay_){0}
    , decltype(_impl_.check_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.uuid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uuid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MoveDoneRequest::~MoveDoneRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MoveDoneRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDoneRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.uuid_.Destroy();
  _impl_.check_name_.Destroy();
}

void MoveDoneRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDoneRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MoveDoneRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.uuid_.ClearToEmpty();
  _impl_.check_name_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.check_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDoneRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1 [json_name = "x"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2 [json_name = "y"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3 [json_name = "z"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rx = 4 [json_name = "rx"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.rx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ry = 5 [json_name = "ry"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.ry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool check = 6 [json_name = "check"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.check_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double delay = 7 [json_name = "delay"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string uuid = 8 [json_name = "uuid"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_uuid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MoveDoneRequest.uuid"));
        } else
          goto handle_unusual;
        continue;
      // string check_name = 9 [json_name = "checkName"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_check_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.MoveDoneRequest.check_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDoneRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MoveDoneRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_rx(), target);
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_ry(), target);
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_check(), target);
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_delay(), target);
  }

  // string uuid = 8 [json_name = "uuid"];
  if (!this->_internal_uuid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_uuid().data(), static_cast<int>(this->_internal_uuid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MoveDoneRequest.uuid");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_uuid(), target);
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_name().data(), static_cast<int>(this->_internal_check_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.MoveDoneRequest.check_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_check_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MoveDoneRequest)
  return target;
}

size_t MoveDoneRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MoveDoneRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string uuid = 8 [json_name = "uuid"];
  if (!this->_internal_uuid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_uuid());
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_name());
  }

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    total_size += 1 + 8;
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    total_size += 1 + 8;
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    total_size += 1 + 8;
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDoneRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDoneRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDoneRequest::GetClassData() const { return &_class_data_; }


void MoveDoneRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDoneRequest*>(&to_msg);
  auto& from = static_cast<const MoveDoneRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MoveDoneRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_uuid().empty()) {
    _this->_internal_set_uuid(from._internal_uuid());
  }
  if (!from._internal_check_name().empty()) {
    _this->_internal_set_check_name(from._internal_check_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = from._internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    _this->_internal_set_rx(from._internal_rx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = from._internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    _this->_internal_set_ry(from._internal_ry());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = from._internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    _this->_internal_set_delay(from._internal_delay());
  }
  if (from._internal_check() != 0) {
    _this->_internal_set_check(from._internal_check());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDoneRequest::CopyFrom(const MoveDoneRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MoveDoneRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDoneRequest::IsInitialized() const {
  return true;
}

void MoveDoneRequest::InternalSwap(MoveDoneRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.uuid_, lhs_arena,
      &other->_impl_.uuid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.check_name_, lhs_arena,
      &other->_impl_.check_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MoveDoneRequest, _impl_.check_)
      + sizeof(MoveDoneRequest::_impl_.check_)
      - PROTOBUF_FIELD_OFFSET(MoveDoneRequest, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDoneRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[15]);
}

// ===================================================================

class MoveDoneReply::_Internal {
 public:
};

MoveDoneReply::MoveDoneReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.MoveDoneReply)
}
MoveDoneReply::MoveDoneReply(const MoveDoneReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MoveDoneReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.status_ = from._impl_.status_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.MoveDoneReply)
}

inline void MoveDoneReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

MoveDoneReply::~MoveDoneReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.MoveDoneReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MoveDoneReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MoveDoneReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MoveDoneReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.MoveDoneReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MoveDoneReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool status = 1 [json_name = "status"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MoveDoneReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.MoveDoneReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.MoveDoneReply)
  return target;
}

size_t MoveDoneReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.MoveDoneReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool status = 1 [json_name = "status"];
  if (this->_internal_status() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MoveDoneReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MoveDoneReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MoveDoneReply::GetClassData() const { return &_class_data_; }


void MoveDoneReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MoveDoneReply*>(&to_msg);
  auto& from = static_cast<const MoveDoneReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.MoveDoneReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MoveDoneReply::CopyFrom(const MoveDoneReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.MoveDoneReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveDoneReply::IsInitialized() const {
  return true;
}

void MoveDoneReply::InternalSwap(MoveDoneReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.status_, other->_impl_.status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MoveDoneReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[16]);
}

// ===================================================================

class CreateCronJobRequest::_Internal {
 public:
  static const ::htpp::machine::service::v1::CronJob& cron_job(const CreateCronJobRequest* msg);
};

const ::htpp::machine::service::v1::CronJob&
CreateCronJobRequest::_Internal::cron_job(const CreateCronJobRequest* msg) {
  return *msg->_impl_.cron_job_;
}
CreateCronJobRequest::CreateCronJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CreateCronJobRequest)
}
CreateCronJobRequest::CreateCronJobRequest(const CreateCronJobRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CreateCronJobRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_job_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cron_job()) {
    _this->_impl_.cron_job_ = new ::htpp::machine::service::v1::CronJob(*from._impl_.cron_job_);
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CreateCronJobRequest)
}

inline void CreateCronJobRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_job_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CreateCronJobRequest::~CreateCronJobRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CreateCronJobRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CreateCronJobRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cron_job_;
}

void CreateCronJobRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CreateCronJobRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CreateCronJobRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.cron_job_ != nullptr) {
    delete _impl_.cron_job_;
  }
  _impl_.cron_job_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CreateCronJobRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cron_job(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CreateCronJobRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CreateCronJobRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
  if (this->_internal_has_cron_job()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cron_job(this),
        _Internal::cron_job(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CreateCronJobRequest)
  return target;
}

size_t CreateCronJobRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CreateCronJobRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
  if (this->_internal_has_cron_job()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cron_job_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CreateCronJobRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CreateCronJobRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CreateCronJobRequest::GetClassData() const { return &_class_data_; }


void CreateCronJobRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CreateCronJobRequest*>(&to_msg);
  auto& from = static_cast<const CreateCronJobRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CreateCronJobRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cron_job()) {
    _this->_internal_mutable_cron_job()->::htpp::machine::service::v1::CronJob::MergeFrom(
        from._internal_cron_job());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CreateCronJobRequest::CopyFrom(const CreateCronJobRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CreateCronJobRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateCronJobRequest::IsInitialized() const {
  return true;
}

void CreateCronJobRequest::InternalSwap(CreateCronJobRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.cron_job_, other->_impl_.cron_job_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CreateCronJobRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[17]);
}

// ===================================================================

class DeleteCronJobRequest::_Internal {
 public:
};

DeleteCronJobRequest::DeleteCronJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.DeleteCronJobRequest)
}
DeleteCronJobRequest::DeleteCronJobRequest(const DeleteCronJobRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteCronJobRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.DeleteCronJobRequest)
}

inline void DeleteCronJobRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeleteCronJobRequest::~DeleteCronJobRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.DeleteCronJobRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteCronJobRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeleteCronJobRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteCronJobRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.DeleteCronJobRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteCronJobRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteCronJobRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.DeleteCronJobRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.DeleteCronJobRequest)
  return target;
}

size_t DeleteCronJobRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.DeleteCronJobRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteCronJobRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteCronJobRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteCronJobRequest::GetClassData() const { return &_class_data_; }


void DeleteCronJobRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteCronJobRequest*>(&to_msg);
  auto& from = static_cast<const DeleteCronJobRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.DeleteCronJobRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteCronJobRequest::CopyFrom(const DeleteCronJobRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.DeleteCronJobRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteCronJobRequest::IsInitialized() const {
  return true;
}

void DeleteCronJobRequest::InternalSwap(DeleteCronJobRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteCronJobRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[18]);
}

// ===================================================================

class DeleteCronJobReply::_Internal {
 public:
};

DeleteCronJobReply::DeleteCronJobReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.DeleteCronJobReply)
}
DeleteCronJobReply::DeleteCronJobReply(const DeleteCronJobReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DeleteCronJobReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.num_ = from._impl_.num_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.DeleteCronJobReply)
}

inline void DeleteCronJobReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.num_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DeleteCronJobReply::~DeleteCronJobReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.DeleteCronJobReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DeleteCronJobReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeleteCronJobReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DeleteCronJobReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.DeleteCronJobReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.num_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteCronJobReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 num = 1 [json_name = "num"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DeleteCronJobReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.DeleteCronJobReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 num = 1 [json_name = "num"];
  if (this->_internal_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_num(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.DeleteCronJobReply)
  return target;
}

size_t DeleteCronJobReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.DeleteCronJobReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 num = 1 [json_name = "num"];
  if (this->_internal_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteCronJobReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DeleteCronJobReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteCronJobReply::GetClassData() const { return &_class_data_; }


void DeleteCronJobReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DeleteCronJobReply*>(&to_msg);
  auto& from = static_cast<const DeleteCronJobReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.DeleteCronJobReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_num() != 0) {
    _this->_internal_set_num(from._internal_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteCronJobReply::CopyFrom(const DeleteCronJobReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.DeleteCronJobReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteCronJobReply::IsInitialized() const {
  return true;
}

void DeleteCronJobReply::InternalSwap(DeleteCronJobReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.num_, other->_impl_.num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteCronJobReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[19]);
}

// ===================================================================

class ListCronJobRequest::_Internal {
 public:
};

ListCronJobRequest::ListCronJobRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.ListCronJobRequest)
}
ListCronJobRequest::ListCronJobRequest(const ListCronJobRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ListCronJobRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.ListCronJobRequest)
}

inline void ListCronJobRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListCronJobRequest::~ListCronJobRequest() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.ListCronJobRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ListCronJobRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
}

void ListCronJobRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ListCronJobRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.ListCronJobRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ListCronJobRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string machine_id = 1 [json_name = "machineId"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.ListCronJobRequest.machine_id"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ListCronJobRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.ListCronJobRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.ListCronJobRequest.machine_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_machine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.ListCronJobRequest)
  return target;
}

size_t ListCronJobRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.ListCronJobRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 1 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ListCronJobRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ListCronJobRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ListCronJobRequest::GetClassData() const { return &_class_data_; }


void ListCronJobRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ListCronJobRequest*>(&to_msg);
  auto& from = static_cast<const ListCronJobRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.ListCronJobRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ListCronJobRequest::CopyFrom(const ListCronJobRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.ListCronJobRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListCronJobRequest::IsInitialized() const {
  return true;
}

void ListCronJobRequest::InternalSwap(ListCronJobRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ListCronJobRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[20]);
}

// ===================================================================

class CronJobReply::_Internal {
 public:
  static const ::htpp::machine::service::v1::CronJob& cron_job(const CronJobReply* msg);
};

const ::htpp::machine::service::v1::CronJob&
CronJobReply::_Internal::cron_job(const CronJobReply* msg) {
  return *msg->_impl_.cron_job_;
}
CronJobReply::CronJobReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CronJobReply)
}
CronJobReply::CronJobReply(const CronJobReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CronJobReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_job_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cron_job()) {
    _this->_impl_.cron_job_ = new ::htpp::machine::service::v1::CronJob(*from._impl_.cron_job_);
  }
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CronJobReply)
}

inline void CronJobReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_job_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CronJobReply::~CronJobReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CronJobReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CronJobReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cron_job_;
}

void CronJobReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CronJobReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CronJobReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.cron_job_ != nullptr) {
    delete _impl_.cron_job_;
  }
  _impl_.cron_job_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CronJobReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cron_job(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CronJobReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CronJobReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
  if (this->_internal_has_cron_job()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::cron_job(this),
        _Internal::cron_job(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CronJobReply)
  return target;
}

size_t CronJobReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CronJobReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.CronJob cron_job = 1 [json_name = "cronJob"];
  if (this->_internal_has_cron_job()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cron_job_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CronJobReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CronJobReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CronJobReply::GetClassData() const { return &_class_data_; }


void CronJobReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CronJobReply*>(&to_msg);
  auto& from = static_cast<const CronJobReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CronJobReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cron_job()) {
    _this->_internal_mutable_cron_job()->::htpp::machine::service::v1::CronJob::MergeFrom(
        from._internal_cron_job());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CronJobReply::CopyFrom(const CronJobReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CronJobReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CronJobReply::IsInitialized() const {
  return true;
}

void CronJobReply::InternalSwap(CronJobReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.cron_job_, other->_impl_.cron_job_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CronJobReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[21]);
}

// ===================================================================

class CronJobsReply::_Internal {
 public:
};

CronJobsReply::CronJobsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CronJobsReply)
}
CronJobsReply::CronJobsReply(const CronJobsReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CronJobsReply* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_jobs_){from._impl_.cron_jobs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CronJobsReply)
}

inline void CronJobsReply::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cron_jobs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CronJobsReply::~CronJobsReply() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CronJobsReply)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CronJobsReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cron_jobs_.~RepeatedPtrField();
}

void CronJobsReply::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CronJobsReply::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CronJobsReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cron_jobs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CronJobsReply::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .htpp.machine.service.v1.CronJob cron_jobs = 1 [json_name = "cronJobs"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cron_jobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CronJobsReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CronJobsReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.CronJob cron_jobs = 1 [json_name = "cronJobs"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cron_jobs_size()); i < n; i++) {
    const auto& repfield = this->_internal_cron_jobs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CronJobsReply)
  return target;
}

size_t CronJobsReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CronJobsReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.CronJob cron_jobs = 1 [json_name = "cronJobs"];
  total_size += 1UL * this->_internal_cron_jobs_size();
  for (const auto& msg : this->_impl_.cron_jobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CronJobsReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CronJobsReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CronJobsReply::GetClassData() const { return &_class_data_; }


void CronJobsReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CronJobsReply*>(&to_msg);
  auto& from = static_cast<const CronJobsReply&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CronJobsReply)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.cron_jobs_.MergeFrom(from._impl_.cron_jobs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CronJobsReply::CopyFrom(const CronJobsReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CronJobsReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CronJobsReply::IsInitialized() const {
  return true;
}

void CronJobsReply::InternalSwap(CronJobsReply* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cron_jobs_.InternalSwap(&other->_impl_.cron_jobs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CronJobsReply::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[22]);
}

// ===================================================================

class CronJob::_Internal {
 public:
};

CronJob::CronJob(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CronJob)
}
CronJob::CronJob(const CronJob& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CronJob* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.check_coordinates_){from._impl_.check_coordinates_}
    , decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.cron_string_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_name().empty()) {
    _this->_impl_.check_name_.Set(from._internal_check_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.cron_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cron_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_cron_string().empty()) {
    _this->_impl_.cron_string_.Set(from._internal_cron_string(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CronJob)
}

inline void CronJob::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.check_coordinates_){arena}
    , decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.cron_string_){}
    , decltype(_impl_.id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cron_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cron_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CronJob::~CronJob() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CronJob)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CronJob::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.check_coordinates_.~RepeatedPtrField();
  _impl_.machine_id_.Destroy();
  _impl_.check_name_.Destroy();
  _impl_.cron_string_.Destroy();
}

void CronJob::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CronJob::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CronJob)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.check_coordinates_.Clear();
  _impl_.machine_id_.ClearToEmpty();
  _impl_.check_name_.ClearToEmpty();
  _impl_.cron_string_.ClearToEmpty();
  _impl_.id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CronJob::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 id = 1 [json_name = "id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string machine_id = 2 [json_name = "machineId"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.CronJob.machine_id"));
        } else
          goto handle_unusual;
        continue;
      // string check_name = 3 [json_name = "checkName"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_check_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.CronJob.check_name"));
        } else
          goto handle_unusual;
        continue;
      // string cron_string = 4 [json_name = "cronString"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_cron_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.CronJob.cron_string"));
        } else
          goto handle_unusual;
        continue;
      // repeated .htpp.machine.service.v1.CheckCoordinate check_coordinates = 5 [json_name = "checkCoordinates"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_check_coordinates(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CronJob::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CronJob)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
  }

  // string machine_id = 2 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.CronJob.machine_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_machine_id(), target);
  }

  // string check_name = 3 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_name().data(), static_cast<int>(this->_internal_check_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.CronJob.check_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_check_name(), target);
  }

  // string cron_string = 4 [json_name = "cronString"];
  if (!this->_internal_cron_string().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_cron_string().data(), static_cast<int>(this->_internal_cron_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.CronJob.cron_string");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_cron_string(), target);
  }

  // repeated .htpp.machine.service.v1.CheckCoordinate check_coordinates = 5 [json_name = "checkCoordinates"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_check_coordinates_size()); i < n; i++) {
    const auto& repfield = this->_internal_check_coordinates(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CronJob)
  return target;
}

size_t CronJob::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CronJob)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .htpp.machine.service.v1.CheckCoordinate check_coordinates = 5 [json_name = "checkCoordinates"];
  total_size += 1UL * this->_internal_check_coordinates_size();
  for (const auto& msg : this->_impl_.check_coordinates_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string machine_id = 2 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  // string check_name = 3 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_name());
  }

  // string cron_string = 4 [json_name = "cronString"];
  if (!this->_internal_cron_string().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cron_string());
  }

  // int64 id = 1 [json_name = "id"];
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CronJob::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CronJob::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CronJob::GetClassData() const { return &_class_data_; }


void CronJob::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CronJob*>(&to_msg);
  auto& from = static_cast<const CronJob&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CronJob)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.check_coordinates_.MergeFrom(from._impl_.check_coordinates_);
  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  if (!from._internal_check_name().empty()) {
    _this->_internal_set_check_name(from._internal_check_name());
  }
  if (!from._internal_cron_string().empty()) {
    _this->_internal_set_cron_string(from._internal_cron_string());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CronJob::CopyFrom(const CronJob& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CronJob)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CronJob::IsInitialized() const {
  return true;
}

void CronJob::InternalSwap(CronJob* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.check_coordinates_.InternalSwap(&other->_impl_.check_coordinates_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.check_name_, lhs_arena,
      &other->_impl_.check_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cron_string_, lhs_arena,
      &other->_impl_.cron_string_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CronJob::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[23]);
}

// ===================================================================

class CheckCoordinate::_Internal {
 public:
  static const ::htpp::machine::service::v1::Coordinate& crd(const CheckCoordinate* msg);
};

const ::htpp::machine::service::v1::Coordinate&
CheckCoordinate::_Internal::crd(const CheckCoordinate* msg) {
  return *msg->_impl_.crd_;
}
CheckCoordinate::CheckCoordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.CheckCoordinate)
}
CheckCoordinate::CheckCoordinate(const CheckCoordinate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckCoordinate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.crd_){nullptr}
    , decltype(_impl_.seq_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_crd()) {
    _this->_impl_.crd_ = new ::htpp::machine::service::v1::Coordinate(*from._impl_.crd_);
  }
  _this->_impl_.seq_ = from._impl_.seq_;
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.CheckCoordinate)
}

inline void CheckCoordinate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.crd_){nullptr}
    , decltype(_impl_.seq_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CheckCoordinate::~CheckCoordinate() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.CheckCoordinate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckCoordinate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.crd_;
}

void CheckCoordinate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckCoordinate::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.CheckCoordinate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.crd_ != nullptr) {
    delete _impl_.crd_;
  }
  _impl_.crd_ = nullptr;
  _impl_.seq_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckCoordinate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 seq = 1 [json_name = "seq"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .htpp.machine.service.v1.Coordinate crd = 2 [json_name = "crd"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_crd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckCoordinate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.CheckCoordinate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 seq = 1 [json_name = "seq"];
  if (this->_internal_seq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seq(), target);
  }

  // .htpp.machine.service.v1.Coordinate crd = 2 [json_name = "crd"];
  if (this->_internal_has_crd()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::crd(this),
        _Internal::crd(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.CheckCoordinate)
  return target;
}

size_t CheckCoordinate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.CheckCoordinate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .htpp.machine.service.v1.Coordinate crd = 2 [json_name = "crd"];
  if (this->_internal_has_crd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.crd_);
  }

  // int64 seq = 1 [json_name = "seq"];
  if (this->_internal_seq() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seq());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckCoordinate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckCoordinate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckCoordinate::GetClassData() const { return &_class_data_; }


void CheckCoordinate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckCoordinate*>(&to_msg);
  auto& from = static_cast<const CheckCoordinate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.CheckCoordinate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_crd()) {
    _this->_internal_mutable_crd()->::htpp::machine::service::v1::Coordinate::MergeFrom(
        from._internal_crd());
  }
  if (from._internal_seq() != 0) {
    _this->_internal_set_seq(from._internal_seq());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckCoordinate::CopyFrom(const CheckCoordinate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.CheckCoordinate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckCoordinate::IsInitialized() const {
  return true;
}

void CheckCoordinate::InternalSwap(CheckCoordinate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CheckCoordinate, _impl_.seq_)
      + sizeof(CheckCoordinate::_impl_.seq_)
      - PROTOBUF_FIELD_OFFSET(CheckCoordinate, _impl_.crd_)>(
          reinterpret_cast<char*>(&_impl_.crd_),
          reinterpret_cast<char*>(&other->_impl_.crd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckCoordinate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[24]);
}

// ===================================================================

class Coordinate::_Internal {
 public:
};

Coordinate::Coordinate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:htpp.machine.service.v1.Coordinate)
}
Coordinate::Coordinate(const Coordinate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Coordinate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.rx_){}
    , decltype(_impl_.ry_){}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.check_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_machine_id().empty()) {
    _this->_impl_.machine_id_.Set(from._internal_machine_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_check_name().empty()) {
    _this->_impl_.check_name_.Set(from._internal_check_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.check_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  // @@protoc_insertion_point(copy_constructor:htpp.machine.service.v1.Coordinate)
}

inline void Coordinate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.machine_id_){}
    , decltype(_impl_.check_name_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.rx_){0}
    , decltype(_impl_.ry_){0}
    , decltype(_impl_.delay_){0}
    , decltype(_impl_.check_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.machine_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.check_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.check_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Coordinate::~Coordinate() {
  // @@protoc_insertion_point(destructor:htpp.machine.service.v1.Coordinate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Coordinate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.machine_id_.Destroy();
  _impl_.check_name_.Destroy();
}

void Coordinate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Coordinate::Clear() {
// @@protoc_insertion_point(message_clear_start:htpp.machine.service.v1.Coordinate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.machine_id_.ClearToEmpty();
  _impl_.check_name_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.check_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.check_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Coordinate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double x = 1 [json_name = "x"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double y = 2 [json_name = "y"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double z = 3 [json_name = "z"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double rx = 4 [json_name = "rx"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.rx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double ry = 5 [json_name = "ry"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.ry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool check = 6 [json_name = "check"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.check_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double delay = 7 [json_name = "delay"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string machine_id = 8 [json_name = "machineId"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.Coordinate.machine_id"));
        } else
          goto handle_unusual;
        continue;
      // string check_name = 9 [json_name = "checkName"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_check_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "htpp.machine.service.v1.Coordinate.check_name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Coordinate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:htpp.machine.service.v1.Coordinate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_x(), target);
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_y(), target);
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_z(), target);
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_rx(), target);
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_ry(), target);
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_check(), target);
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_delay(), target);
  }

  // string machine_id = 8 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_machine_id().data(), static_cast<int>(this->_internal_machine_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.Coordinate.machine_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_machine_id(), target);
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_check_name().data(), static_cast<int>(this->_internal_check_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "htpp.machine.service.v1.Coordinate.check_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_check_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:htpp.machine.service.v1.Coordinate)
  return target;
}

size_t Coordinate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:htpp.machine.service.v1.Coordinate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string machine_id = 8 [json_name = "machineId"];
  if (!this->_internal_machine_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_machine_id());
  }

  // string check_name = 9 [json_name = "checkName"];
  if (!this->_internal_check_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_check_name());
  }

  // double x = 1 [json_name = "x"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 8;
  }

  // double y = 2 [json_name = "y"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 8;
  }

  // double z = 3 [json_name = "z"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 8;
  }

  // double rx = 4 [json_name = "rx"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = this->_internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    total_size += 1 + 8;
  }

  // double ry = 5 [json_name = "ry"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = this->_internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    total_size += 1 + 8;
  }

  // double delay = 7 [json_name = "delay"];
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = this->_internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    total_size += 1 + 8;
  }

  // bool check = 6 [json_name = "check"];
  if (this->_internal_check() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Coordinate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Coordinate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Coordinate::GetClassData() const { return &_class_data_; }


void Coordinate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Coordinate*>(&to_msg);
  auto& from = static_cast<const Coordinate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:htpp.machine.service.v1.Coordinate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_machine_id().empty()) {
    _this->_internal_set_machine_id(from._internal_machine_id());
  }
  if (!from._internal_check_name().empty()) {
    _this->_internal_set_check_name(from._internal_check_name());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_rx = from._internal_rx();
  uint64_t raw_rx;
  memcpy(&raw_rx, &tmp_rx, sizeof(tmp_rx));
  if (raw_rx != 0) {
    _this->_internal_set_rx(from._internal_rx());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_ry = from._internal_ry();
  uint64_t raw_ry;
  memcpy(&raw_ry, &tmp_ry, sizeof(tmp_ry));
  if (raw_ry != 0) {
    _this->_internal_set_ry(from._internal_ry());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_delay = from._internal_delay();
  uint64_t raw_delay;
  memcpy(&raw_delay, &tmp_delay, sizeof(tmp_delay));
  if (raw_delay != 0) {
    _this->_internal_set_delay(from._internal_delay());
  }
  if (from._internal_check() != 0) {
    _this->_internal_set_check(from._internal_check());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Coordinate::CopyFrom(const Coordinate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:htpp.machine.service.v1.Coordinate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coordinate::IsInitialized() const {
  return true;
}

void Coordinate::InternalSwap(Coordinate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.machine_id_, lhs_arena,
      &other->_impl_.machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.check_name_, lhs_arena,
      &other->_impl_.check_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Coordinate, _impl_.check_)
      + sizeof(Coordinate::_impl_.check_)
      - PROTOBUF_FIELD_OFFSET(Coordinate, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Coordinate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_getter, &descriptor_table_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto_once,
      file_level_metadata_apis_2fhtpp_2fmachine_2fservice_2fv1_2fmachine_2eproto[25]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace service
}  // namespace machine
}  // namespace htpp
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::FindByUserIdRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::FindByUserIdRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::FindByUserIdRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CreateRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CreateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CreateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::UpdateRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::UpdateRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::UpdateRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::GetRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::GetRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::GetRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MoveRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MoveRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MoveRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MoveReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MoveReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MoveReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MachineReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MachineReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MachineReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MachinesReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MachinesReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MachinesReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MachineStruct*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MachineStruct >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MachineStruct >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::ZeroRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::ZeroRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::ZeroRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::ZeroReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::ZeroReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::ZeroReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::GetMotorStatusRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::GetMotorStatusRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::GetMotorStatusRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::GetMotorStatusReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::GetMotorStatusReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::GetMotorStatusReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MotorInfo*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MotorInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MotorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MotorStatus*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MotorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MotorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MoveDoneRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MoveDoneRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MoveDoneRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::MoveDoneReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::MoveDoneReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::MoveDoneReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CreateCronJobRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CreateCronJobRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CreateCronJobRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::DeleteCronJobRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::DeleteCronJobRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::DeleteCronJobRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::DeleteCronJobReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::DeleteCronJobReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::DeleteCronJobReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::ListCronJobRequest*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::ListCronJobRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::ListCronJobRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CronJobReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CronJobReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CronJobReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CronJobsReply*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CronJobsReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CronJobsReply >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CronJob*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CronJob >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CronJob >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::CheckCoordinate*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::CheckCoordinate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::CheckCoordinate >(arena);
}
template<> PROTOBUF_NOINLINE ::htpp::machine::service::v1::Coordinate*
Arena::CreateMaybeMessage< ::htpp::machine::service::v1::Coordinate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::htpp::machine::service::v1::Coordinate >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
